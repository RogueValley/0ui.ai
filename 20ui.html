<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rogue LLM Chat</title>
    <link rel="manifest" href="manifest.json" crossorigin="use-credentials">
</head>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
html {
  height: 100%;
}
body {
  font-family: Arial, sans-serif;
  line-height: 1.6;
  color: #333;
  background-color: #f9f9f9;
  font-size: 16px;
  height: 100vh; 
  width: 100vw; 
  margin: 0; 

  top: 0;
  left: 0;
  min-height: 100vh;
  max-height: 100vh;
}

.nav-bar {
  position: fixed;
  top: 0;
  height: 4dvh; 
  display: flex;
  justify-content: space-between;
  background-color: #444;
  color: #ddd;
  padding-top: .5dvh;
  justify-content: flex-end;
  width: 100dvw;
}

.nav-bar-button {
  padding-right: 2dvh;
  padding: .5dvh;
  border: .2dvh solid #ccc;
  border-radius: 2dvh;
  background-color: #408000;
  width: fit-content; /* Added to size the container to its content horizontally */
  height: fit-content; /* Added to size the container to its content vertically */

  margin-right: 2dvw;
  font-size: 1.5dvh;

  font-weight: bold;
  cursor: pointer;
}

.nav-bar-button:hover {
  background-color: #222; /* Change background color on hover */
  color: #ddd; /* or color: white; */
}


.app-logo {
  margin-right: auto;
  font-size: 2dvh;
  padding-left:  .5dvh;
  padding-right: 1dvh;
  color: #00dd00; /* neon green */
  text-shadow: 0 0 10px rgba(0, 200, 0, 0.5); /* glow effect */
  font-weight: bold; /* bold font */
  font-family: 'Arial Black', sans-serif; /* modern font */
 background-color: #333; /* dark gray background */
   border-radius: 10px; /* rounded corners */
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); /* shadow effect */
  width: fit-content; /* Added to size the container to its content vertically */
  display: flex; /* Add this to use flexbox for icon and text alignment */
  align-items: center; /* Vertically center the icon and text */
}

.app-logo::before {
  content: "";
  background-image: url('Rogue_icon.png');
  background-size: contain;
  width: 3dvh; /* Adjust the width to fit your icon size */
  height: 3dvh; /* Adjust the height to fit your icon size */
  margin-right: 1dvh; /* Add some space between the icon and text */
}


 
#loading-indicator {
  position: absolute;
  top: 30vh;
  left: 50%;
  transform: translateX(-50%);
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background-color: #000000;
  height: 14dvh;
}

#loading-indicator img {
  width: 22dvh; /* adjust the width to your liking */
  height: 22dvh;
}

.chat-body-container {  
  position: fixed;
  top: 4dvh;
  justify-content: start; /* Keep this */
  align-items: center;
  background-color: #444000;
  width: 100%; /* Make it full width */
  height: 88dvh;

  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
  cursor: text;
}

.chat-body {
  padding: 10px;
  padding-bottom: 1dvh;
  border-radius: 10px;
  overflow-y: auto; /* Allow the chat body to scroll */
  max-height: 100%; /* Set the maximum height of the chat body to the height of the container */
  

}

.chat-body pre {
  display: block; /* Changed from flex to block */
  margin-bottom: 2dvh;
  padding: 10px;
  border-radius: 10px;  

}

.user-bubble {
  display: block;
  padding: 10px;
  border-radius: 10px;
  background-image: linear-gradient(to bottom right, #03131a, #4682B4);
  color: #dddddd;
  white-space: pre-wrap; /* Allows text to wrap */
  word-wrap: break-word; /* Breaks long words */
  overflow-wrap: break-word; /* For very long words without spaces */
  pointer-events: auto;
}

.ai-bubble {
  display: block;
  padding: 10px;
  border-radius: 10px;
  background-image: linear-gradient(to bottom right, #599216, #679468);
  color: #000000;
  white-space: pre-wrap; /* Allows text to wrap */
  word-wrap: break-word; /* Breaks long words */
  overflow-wrap: break-word; /* For very long words without spaces */
  pointer-events: auto;
}


.button-save {
  font-size: 1.5dvh;
  font-weight: bold;
  width: 6dvh;
  height: 5dvh;
  margin-left: 2vw;
  border: 0.1vw solid #ccc;
  border-radius: 2vw;
  background-color: #444;
  color: #ddd;
  cursor: pointer;
}

.button-close {
  font-size: 1.5dvh;
  font-weight: bold;
  width: 6dvh;
  height: 5dvh;
  margin-left: 4vw;
  border: 0.1vw solid #ff0;
  border-radius: 2vw;
  background-color: #ff0080;
  color: #ddd;
  cursor: pointer;
}

#app-system-prompt-input{
  width: 98%;
  height: 20dvh;
  padding: 0.5vw;
  font-size: .8rem;
  border: none;
  border-radius: 10px;
  background-color: #ddd;
  white-space: pre-wrap; /* Allows text to wrap */
  word-wrap: break-word; /* Breaks long words */
  overflow-wrap: break-word; /* For very long words without spaces */
}

footer {
  position: fixed;
  bottom: 0;
  left: 0;

  width: 100vw;
  height: 8vh;
  max-height: 10vh; /* set a maximum height in pixels */
  background-color: #444;
  overflow-y: auto; /* add this to hide excess content if it exceeds the max height */
  align-items: center;
}

.input-section {
  align-items: center;
  height: clamp(2dvh, 4dvw, 3dvh); /* changed to auto */
  margin-left: 5vw;
  position: fixed;
  bottom: .5dvw;
  width: 85vw;
  padding: 1dvw; 
  padding-right: 1dvw;
  background-color: #555;
  border-radius: 4vw;
  display: flex;
  padding-top: 1vh;
  padding-bottom: 1vh;  
  height: fit-content; /* Added to size the container to its content vertically */
}

#user-input {
  width: 90dvw; /* fixed width relative to viewport */
  height: 4dvh; /* changed to auto */
  min-height: 4dvh; /* minimum height */
  font-size: clamp(.1dvh, 4dvh, 4dvw); /* cap font size based on width and height */
  border-radius: 2vw;
 
  padding: 1dvh; /* consistent padding relative to viewport */
  font-size: clamp(.1dvh, 4dvw, 2.5dvh); /* cap font size based on width and height */
  border: 1px solid #ddd; /* improved border color and width relative to viewport */
  box-shadow: 0 0 1px rgba(0, 0, 0, 0.1); /* added subtle shadow for depth relative to viewport */
  font-family: Arial, sans-serif; /* added font family for better typography */
  resize: vertical; /* allow resizing vertically */
  transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s ease-in-out;
  overflow-y: hidden; /* hide scrollbar */
}

#user-input::-webkit-scrollbar {
  display: none; /* hide scrollbar for Chrome and Safari */
}

#user-input::-moz-scrollbar {
  display: none; /* hide scrollbar for Firefox */
}

#user-input:focus {
  outline: none;
  -webkit-appearance: none; /* remove default Chrome/Mac focus ring */
  -moz-appearance: none; /* remove default Firefox focus ring */
  border-color: #005500; /* green border */
  box-shadow: 0 0 5px rgba(0, 255, 0, 0.5); /* green glow */
  background-color: #add8e6; /* light blue background */
  overflow-y: hidden; /* hide scrollbar */
}



#user-input.normal {
  overflow-y: hidden; 
  max-height: clamp(2dvh, 4dvw, 3dvh); /* cap font size based on width and height */
}

#user-input.expanded {
  max-height: 40vh; 
  overflow-y: auto; 
}

#send-button {
  font-size: clamp(.1dvh, 4dvw, 2.5dvh);
  font-weight: bold;
  margin-left: 1vw;
  padding: 1vw;
  padding-top: .2vw;
  padding-bottom: .2vw;  
  width: fit-content; /* Added to size the container to its content horizontally */
  height: fit-content; /* Added to size the container to its content vertically */

  border: 1px solid #ccc;
  border-radius: 2vw;
  cursor: pointer;
}

#send-button:hover {
  background-color: #222; /* Change background color on hover */
  color: #ddd;/* or color: white; */
}

#settings-panel {
  position: fixed;
  display: none; /* changed to flex */
  top: 8vh;
  height: 80dvh;
  width: 80dvw;
  flex-wrap: wrap; /* Allow containers to wrap to a new line */
  justify-content: space-around; /* Distribute containers horizontally */
  align-items: flex-start; /* Align containers to the top */
  gap: 10px; /* Add some spacing between containers */
  margin-left: 10dvw; 
  margin-right: 10dvw; 
  background-color: rgba(128, 128, 128, 0.5); /* gray and semi-transparent background */
}

#settings-panel.hidden {
  z-index: -1;
}


#app-settings-container,
#cloud-settings-container,
#llm-settings-container,
#chat-options-container {
  display: flex;
  padding: 1rem;
  background-color: #808000;
  border-radius: 10px;
  margin: 0.5rem; 
  width: fit-content; 
  height: fit-content; 
  font-size: .6rem;
  flex-direction: column; 
}



.black {
  background-color: #111111;
}
.green {
  background-color: #408000;
}
.yellow {
  background-color: #FF8000;
}
.red {
  background-color: #FF0000;
}
.active {
  background-color: #444111;
}
.hidden {
  display: none;
}</style>


<body>
  <!-- Navigation Bar -->
  <nav class="nav-bar" id="nav-bar">
    <div class="app-logo" id="app-logo">Rogue 0Nex</div>
    <button id="app-settings-button" class="nav-bar-button" aria-label="Open app settings menu">⚙️ App</button>
    <button id="cloud-settings-button" class="nav-bar-button" aria-label="Open cloud settings menu">☁️ Cloud</button>
    <button id="llm-settings-button" class="nav-bar-button" aria-label="Open LLM settings menu">✨ LLM</button>
  </nav>

  <!-- Loading Indicator -->
  <div id="loading-indicator">
    <img src="loading.gif" alt="Loading...">
  </div>

  <!-- Chat Body -->
  <div class="chat-body-container" id="chat-body-container">
    <div class="chat-body" id="chat-body"></div>
  </div>

  <!-- Input Section -->
  <footer id="footer">
    <div class="input-section" id="input-section">
      <textarea id="user-input" class="normal" wrap="soft" placeholder="Type a message..."></textarea>
      <button id="send-button" type="button">Send</button>
    </div>
  </footer>

  <!-- Settings Panel -->
  <div id="settings-panel" class="settings-panel">

    <!-- App Settings -->
    <div id="app-settings-container" class="settings-group hidden">
      <h2>App Settings</h2>
      <form id="app-settings-form">
        <p>Screen Height: <span id="screen-height-value"></span></p>
        <p>Window Height: <span id="window-height-value"></span></p>
        <p>Screen Width: <span id="screen-width-display"></span></p>
        <p>Window Width: <span id="window-width-display"></span></p>
      </form>

      <label>System Prompt:</label>
      <textarea id="app-system-prompt-input" wrap="soft" placeholder="Type a message..."></textarea>

      <div class="button-container">
        <button id="app-save-sysprompt-button" class="button-save">&#128190; SAVE</button>
        <button id="app-settings-button-close" class="button-close" aria-label="Close app settings menu">&#9194; Close</button>
      </div>
    </div>

    <!-- Cloud Settings -->
    <div id="cloud-settings-container" class="settings-group hidden">
      <h2>Cloud Settings</h2>
      <form id="cloud-settings-form">
        <label for="api-url">API URL:</label>
        <input type="text" id="api-url" name="api-url">

        <label for="client-id">Client ID:</label>
        <input type="text" id="client-id" name="client-id">

        <label for="client-secret">Client Secret:</label>
        <input type="text" id="client-secret" name="client-secret">

        <label for="client-stream">Client Stream:</label>
        <input type="checkbox" id="client-stream" value="true" checked>
      </form>

      <div class="button-container">
        <button id="save-settings-button" class="button-save">&#128190; Save</button>
        <button id="cloud-settings-button-close" class="button-close">&#9194; Close</button>
      </div>
    </div>

    <!-- LLM Settings -->
    <div id="llm-settings-container" class="settings-group hidden">
      <h2>LLM Settings</h2>

      <label for="models-select">Select Model:</label>
      <select id="models-select">
        <option value="">[EMPTY]</option>
      </select>

      <p id="models-active-title">Active Model: <span id="models-active"></span></p>

      <div class="button-container">
        <button id="llm-settings-button-close" class="button-close">&#9194; Close</button>
      </div>
    </div>

  </div>
</body>
<!-- remove the other module tag or combine files -->
<script type="module">







// DOM references
const ChatArea = document.querySelector('#chat-body');
const ChatAreaContainer = ChatArea;
const TempText = document.getElementById('temp-text-area');
const applogo = document.getElementById('app-logo');

let error_out = "";
let connectionReady = false;
let includeCreds = true;

function resetConnection() {
  connectionReady = false;
}

/* ------------------------------
   API REQUEST WRAPPER
--------------------------------*/
async function makeApiRequest(url, method, body = null, headers = null, blockOpen = false) {
  const controller = new AbortController();
  const signal = controller.signal;

  const timeout = headers ? 200000 : 30000;
  const timerId = setTimeout(() => controller.abort(), timeout);

  try {
    const fetchOptions = {
      method,
      ...(headers && { headers }),
      ...(body && { body }),
      ...(includeCreds && { credentials: "include" }),
      ...(!blockOpen && { signal })
    };

    const response = await fetch(url, fetchOptions);
    clearTimeout(timerId);

    if (!response.ok) {
      throw new Error(`API request failed: ${response.status} ${await response.text()}`);
    }

    return response;
  } catch (error) {
    clearTimeout(timerId);
    if (error.name === 'AbortError') return { error: 'Timeout exceeded' };
    return error;
  }
}

/* ------------------------------
   CONNECTION HANDSHAKE
--------------------------------*/
async function establishConnection() {
  if (connectionReady) return;

  const apiUrl = apiUrlInput.value.trim();
  const clientId = clientIdInput.value.trim();
  const clientSecret = clientSecretInput.value.trim();

  loadingIndicator.style.display = 'flex';
  applogo.classList.add('black');

  try {
    // 1. Try with credentials
    includeCreds = true;
    let url = URLadd("/api/ps", apiUrl);
    let response = await makeApiRequest(url, "GET");
    if (response.ok) return (connectionReady = true);

    applogo.classList.add('green');

    // 2. Try with CF Access headers
    if (clientId && clientSecret) {
      const headers = {
        "CF-Access-Client-Id": clientId,
        "CF-Access-Client-Secret": clientSecret,
        "Content-Type": "application/json",
        "ai": "1"
      };
      includeCreds = true;
      response = await makeApiRequest(URLadd("", apiUrl), "GET", null, headers);
      if (response.ok) return (connectionReady = true);
    }

    applogo.classList.add('yellow');

    // 3. Try without credentials
    includeCreds = false;
    response = await makeApiRequest(URLadd("/api/ps", apiUrl), "GET");
    if (response.ok) return (connectionReady = true);

    applogo.classList.add('red');
    throw new Error("Not connected to API");
  } finally {
    loadingIndicator.style.display = 'none';
    applogo.classList.remove('black', 'green', 'yellow', 'red');
  }
}

/* ------------------------------
   LOAD ACTIVE MODEL
--------------------------------*/
async function loadActiveModels() {
  const apiUrl = apiUrlInput.value.trim();
  const modelsactive = document.getElementById('models-active');

  try {
    await establishConnection();
    if (!connectionReady) throw new Error("No connection");

    const res = await makeApiRequest(URLadd("/api/ps", apiUrl), "GET");
    if (!res.ok) throw new Error("Bad response");

    const models = await res.json();

    let selected = models.models[0].name;
    if (selected === "[EMPTY]") throw new Error("Empty model list");

    for (const m of models.models) {
      if (m.name === savedModelSelected) {
        selected = savedModelSelected;
        break;
      }
    }

    modelsSelectDropdown.value = selected;
    savedModelSelected = selected;
    modelsactive.textContent = selected;
  } finally {
    loadingIndicator.style.display = 'none';
  }
}

/* ------------------------------
   LOAD ALL MODELS
--------------------------------*/
async function loadModels() {
  const apiUrl = apiUrlInput.value.trim();

  try {
    await establishConnection();
    loadingIndicator.style.display = 'flex';

    // Clear dropdown
    while (modelsSelectDropdown.options.length) {
      modelsSelectDropdown.remove(0);
    }

    const res = await makeApiRequest(URLadd("/api/tags", apiUrl), "GET");
    if (!res.ok) throw new Error("Bad response");

    const models = await res.json();
    if (!Array.isArray(models.models)) throw new Error("Invalid model list");

    models.models.forEach(model => {
      if (!model.name.includes("embed")) {
        const opt = new Option(model.name, model.name);
        modelsSelectDropdown.add(opt);
      }
    });

    let selected = modelsSelectDropdown.options[0]?.value;
    for (const opt of modelsSelectDropdown.options) {
      if (opt.value === savedModelSelected) {
        selected = savedModelSelected;
        break;
      }
    }

    modelsSelectDropdown.value = selected;
    savedModelSelected = selected;
    localStorage.setItem('modelSelected', selected);
  } finally {
    loadingIndicator.style.display = 'none';
  }
}

/* ------------------------------
   CHAT HISTORY
--------------------------------*/
function GetChatHistory() {
  const bubbles = ChatArea.querySelectorAll('pre');
  return bubbles.length
    ? [...bubbles].map(b => b.textContent).join('\n\n')
    : '';
}

/* ------------------------------
   SEND MESSAGE
--------------------------------*/
async function sendMessage() {
  const apiUrl = apiUrlInput.value.trim();
  const chatMessage = messageInput.value;
  const clientStream = clientStreamInput.value !== "false";
  const modelSelected = savedModelSelected;

  if (!modelSelected || !chatMessage) {
    throw new Error("Missing model or message");
  }

  const messages = { conversation: [] };

  if (systemPrompt) {
    messages.conversation.push({ role: "system", content: systemPrompt });
  }

  const bubbles = ChatArea.querySelectorAll('pre');
  [...bubbles].forEach(b => {
    const text = b.textContent;
    if (text.startsWith("User:")) {
      messages.conversation.push({ role: "user", content: text.replace("User:", "").trim() });
    } else if (text.startsWith("AI:")) {
      messages.conversation.push({ role: "assistant", content: text.replace("AI:", "").trim() });
    }
  });

  messages.conversation.push({ role: "user", content: chatMessage });

  const payload = {
    model: modelSelected,
    messages: messages.conversation,
    stream: clientStream
  };

  await establishConnection();

  const res = await makeApiRequest(
    URLadd("/api/chat", apiUrl),
    "POST",
    JSON.stringify(payload),
    null,
    true
  );

  if (!res.ok) throw new Error("Chat request failed");

  await p(chatMessage, res, payload.stream);
}

/* ------------------------------
   PROCESS RESPONSE
--------------------------------*/
async function p(chatMessage, res, isStream) {
  try {
    createBubble("user", chatMessage);
    ChatAreaContainer.scrollTo({ top: ChatAreaContainer.scrollHeight, behavior: 'smooth' });

    const bubble = createBubble("ai", "");

    if (isStream) {
      const reader = res.body.getReader();
      const processor = new StreamingJsonProcessor();
      let partial = "";

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        partial += new TextDecoder().decode(value);
        const chunks = processor.processChunk(partial);
        partial = "";

        chunks.forEach(content => {
          bubble.textContent += replaceCharEncodings(content);
          resizePre(bubble);
          ChatAreaContainer.scrollTo({ top: ChatAreaContainer.scrollHeight, behavior: 'smooth' });
        });
      }
    } else {
      bubble.textContent += "\n" + await res.text();
    }

    messageInput.focus();
  } finally {
    loadingIndicator.style.display = 'none';
  }
}

/* ------------------------------
   STREAMING JSON PROCESSOR
--------------------------------*/
class StreamingJsonProcessor {
  constructor() {
    this.buffer = "";
  }

  processChunk(chunk) {
    this.buffer += chunk;
    const out = [];

    while (true) {
      const end = this.findNextJsonEndIndex(this.buffer);
      if (end === -1) break;

      const jsonString = this.sanitizeJson(this.buffer.slice(0, end));
      try {
        const content = extractContent(jsonString);
        if (content) out.push(content);
      } catch (e) {
        console.error("JSON parse error:", e);
      }

      this.buffer = this.buffer.slice(end);
    }

    return out;
  }

  findNextJsonEndIndex(str) {
    let depth = 0;
    let inString = false;

    for (let i = 0; i < str.length; i++) {
      const c = str[i];

      if (c === '"' && str[i - 1] !== '\\') inString = !inString;
      if (!inString) {
        if (c === '{' || c === '[') depth++;
        if (c === '}' || c === ']') depth--;
        if (depth === 0) return i + 1;
      }
    }
    return -1;
  }

  sanitizeJson(str) {
    return str.trim().replace(/,\s*([\]}])/g, '$1');
  }
}











/**
 * Fallback safe JSON parse.
 * - Never throws
 * - Rejects incomplete JSON
 * - Strips dangerous keys
 * - Uses secureParse() if available
 */
function safeJsonParse(text) {
  if (typeof text !== 'string' || text.trim() === '') return null;

  // Try secure parser first
  if (typeof secureParse === 'function') {
    try {
      const out = secureParse(text);
      if (out !== undefined) return out;
    } catch {
      // fall through to local parser
    }
  }

  // Local safe fallback
  try {
    return JSON.parse(text, (k, v) => {
      if (k === '__proto__' || k === 'constructor' || k === 'prototype') return undefined;
      if (typeof v === 'function') return undefined;
      return v;
    });
  } catch {
    // Incomplete or invalid JSON
    return null;
  }
}


/**
 * Decode only the escape sequences expected from LLM streams.
 * Conservative by design.
 */
function replaceCharEncodings(text) {
  if (typeof text !== 'string') return '';

  const map = {
    '\\&#10;': '\n',
    '\\&#13;': '\r',
    '\\u003c': '<',
    '\\u003e': '>',
    '\\u0026': '&',
    '\\u0027': "'"
  };

  return text.replace(/\\u[0-9a-fA-F]{4}|\\&#10;|\\&#13;/g, m => {
    if (m.startsWith('\\u')) {
      const hex = m.slice(2);
      return /^[0-9a-fA-F]{4}$/.test(hex)
        ? String.fromCharCode(parseInt(hex, 16))
        : m;
    }
    return map[m] || m;
  });
}


/**
 * Minimal sanitizer for textContent insertion.
 * Removes control chars + risky punctuation.
 */
function sanitizeText(s) {
  if (typeof s !== 'string') return '';
  return s.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F`{}<>]/g, '');
}


/**
 * Extracts content from a JSON fragment.
 * Accepts:
 *   - {"content":"..."}
 *   - {"delta":{"content":"..."}}
 * Returns decoded + sanitized text.
 */
function extractContent(fragment) {
  let obj = fragment;

  if (typeof fragment === 'string') {
    obj = safeJsonParse(fragment);
    if (!obj || typeof obj !== 'object') return null;
  }

  const content =
    (typeof obj.response === 'string' && obj.response) ||
    (obj.delta && typeof obj.delta.response === 'string' && obj.delta.response) ||
    (typeof obj.content === 'string' && obj.content) ||
    (obj.delta && typeof obj.delta.content === 'string' && obj.delta.content) ||
    null;

  if (!content) return null;

  const decoded = replaceCharEncodings(content);
  return sanitizeText(decoded);
}































function guiSizeChange() {
  document.querySelector('.chat-body-container').style.height = '88dvh';
  document.querySelectorAll('.chat-body pre').forEach(resizePre);
}

function saveLayout() {
  localStorage.setItem('chatBodyHeight', chatBodyHeight);
}

function loadLayout() {
  chatBodyHeight = localStorage.getItem('chatBodyHeight');
}


function resizePre(pre) {
  pre.style.height = 'auto';
  pre.style.height = pre.scrollHeight + 'px';
}

function updateBubble(bubble) {
  bubble.style.height = bubble.scrollHeight + 'px';
}

function createBubble(role, text) {
  const bubble = document.createElement('pre');
  const prefix = role === 'user' ? 'User: ' : 'AI: ';

  bubble.className = role === 'user' ? 'user-bubble' : 'ai-bubble';
  bubble.textContent = prefix + text.replace(/\&#10;/g, "\&#13;\&#10;");
  bubble.style.height = 'auto';
  bubble.style.overflowY = 'hidden';
  bubble.rows = 1;
  bubble.disabled = true;

  chatBody.appendChild(bubble);
  bubble.style.height = bubble.scrollHeight + 'px';

  return bubble;
}

function displayTempOutput(tempTextArea) {
  tempTextArea.id = 'ai-bubble';
  tempTextArea.classList.add('ai-bubble');
  tempTextArea.style.display = 'block';
}















// Core chat elements
const chatBody = document.getElementById('chat-body');
const messageInput = document.getElementById('user-input');
const sendButton = document.getElementById('send-button');
const loadingIndicator = document.getElementById('loading-indicator');

// Layout tracking
let chatBodyHeight;
let screenHeight, windowHeight, screenWidth, windowWidth;

const sreenHeightDisplay = document.getElementById('screen-height-value');
const windowHeightDisplay = document.getElementById('window-height-value');
const screenWidthDisplay = document.getElementById('screen-width-display');
const windowWidthDisplay = document.getElementById('window-width-display');

// Settings UI
const cloudSettingsButton = document.getElementById('cloud-settings-button');
const cloudSettingsButtonClose = document.getElementById('cloud-settings-button-close');
const cloudSettingsContainer = document.getElementById('cloud-settings-container');

const appSettingsButton = document.getElementById('app-settings-button');
const appSettingsButtonClose = document.getElementById('app-settings-button-close');
const appSettingsContainer = document.getElementById('app-settings-container');
const appSaveSysPromptButton = document.getElementById('app-save-sysprompt-button');
const syspromptInput = document.getElementById('app-system-prompt-input');

const llmSettingsButton = document.getElementById('llm-settings-button');
const llmSettingsButtonClose = document.getElementById('llm-settings-button-close');
const llmSettingsContainer = document.getElementById('llm-settings-container');
const saveSettingsButton = document.getElementById('save-settings-button');

// Model selection
const modelsSelectDropdown = document.getElementById('models-select');

// Cloud/API inputs
const apiUrlInput = document.getElementById('api-url');
const clientIdInput = document.getElementById('client-id');
const clientSecretInput = document.getElementById('client-secret');
const clientStreamInput = document.getElementById('client-stream');

// Misc UI
const darkModeButton = document.getElementById('dark-mode-button');
const body = document.body;

// Saved values
const savedApiUrl = localStorage.getItem('apiUrl');
const savedClientId = localStorage.getItem('clientId');
const savedClientSecret = localStorage.getItem('clientSecret');
const savedClientStream = localStorage.getItem('clientStream');
const savedDarkMode = localStorage.getItem('dark-mode');
const savedSystempPrompt = localStorage.getItem('system-prompt');
let savedModelSelected = localStorage.getItem('modelSelected');









class Options {
  constructor() {
    this.storageKey = 'options';
    this._options = this._loadFromStorage();
  }

  _loadFromStorage() {
    try {
      const raw = localStorage.getItem(this.storageKey);
      if (!raw) return {};
      const parsed = JSON.parse(raw);
      return (parsed && typeof parsed === 'object') ? parsed : {};
    } catch {
      return {};
    }
  }

  getOptions() {
    return { ...this._options };
  }

  loadOptions() {
    this._options = this._loadFromStorage();
    return this.getOptions();
  }

  saveOptions(opts) {
    if (!opts || typeof opts !== 'object') return false;

    // sanitize + secure save
    const safe = this._sanitize(opts);
    if (!safe) return false;

    this._options = safe;
    localStorage.setItem(this.storageKey, JSON.stringify(safe));
    return true;
  }

  _sanitize(opts) {
    const sensitive = [
      'apiKey', 'apiSecret', 'clientSecret',
      'password', 'token', 'accessToken'
    ];

    const copy = { ...opts };
    for (const k of sensitive) {
      if (k in copy) delete copy[k];
    }

    const replacer = (key, value) =>
      typeof value === 'function' || typeof value === 'undefined'
        ? undefined
        : value;

    try {
      const json = JSON.stringify(copy, replacer);

      if (new Blob([json]).size > 100_000) {
        console.warn('Options: payload too large');
        return null;
      }

      return JSON.parse(json);
    } catch (e) {
      console.error('Options: sanitize failed', e);
      return null;
    }
  }
}

function saveSystemPrompt() {
  // Pull the latest value from the UI
  const value = syspromptInput.value;

  // Update the in‑memory system prompt
  systemPrompt = value;

  // Persist to localStorage
  localStorage.setItem('system-prompt', value);

  // Reset connection so the next request uses the new prompt
  resetConnection();
}


// ------------------------------
// GLOBAL STATE INITIALIZATION
// ------------------------------

// Options manager
const options = new Options();

// Always fetch fresh options when needed
function getCurrentOptions() {
  return options.getOptions();
}

// Cached DOM references
const settingsAside = document.querySelector('.settings-panel');

// Message‑send state
let isSending = false;

// Input behavior
let SendOnEnter = true;

// System prompt (safe fallback)
let systemPrompt = typeof savedSystempPrompt === 'string'
  ? savedSystempPrompt
  : '';

// Load layout settings early
loadLayout();




document.addEventListener('DOMContentLoaded', () => {

  // Initial UI adjustments
  setTimeout(() => requestAnimationFrame(guiSizeChange), 100);
  options.loadOptions();
  messageInput.focus();
  resize_textbox();

  document.querySelector('#models-active').textContent = "";

  // Load saved values
  if (savedApiUrl) apiUrlInput.value = savedApiUrl;
  if (savedClientId) clientIdInput.value = savedClientId;
  if (savedClientSecret) clientSecretInput.value = savedClientSecret;
  if (savedSystempPrompt) systemPrompt = savedSystempPrompt;

  clientStreamInput.checked = savedClientStream !== "true";

  if (savedModelSelected) {
    const opt = new Option(savedModelSelected, savedModelSelected);
    modelsSelectDropdown.add(opt);
    modelsSelectDropdown.value = savedModelSelected;
  }

  if (savedDarkMode === 'true') body.classList.add('dark-mode');

  // ------------------------------
  // SETTINGS PANEL TOGGLES
  // ------------------------------
  const toggleDisplay = el =>
    el.style.display = (el.style.display === 'none' || !el.style.display)
      ? 'flex'
      : 'none';

  cloudSettingsButton.addEventListener('click', () => {
    toggleDisplay(cloudSettingsContainer);
    toggleSettingsAside();
  });

  cloudSettingsButtonClose.addEventListener('click', () => {
    toggleDisplay(cloudSettingsContainer);
    toggleSettingsAside();
  });

  appSettingsButton.addEventListener('click', () => {
    toggleDisplay(appSettingsContainer);
    if (appSettingsContainer.style.display === 'flex') {
      syspromptInput.value = localStorage.getItem('system-prompt');
      guiSizeChange();
    }
    toggleSettingsAside();
  });

  llmSettingsButton.addEventListener('click', () => {
    if (llmSettingsContainer.style.display === 'none' || !llmSettingsContainer.style.display) {
      loadModels();
      loadActiveModels();
    }
    toggleDisplay(llmSettingsContainer);
    toggleSettingsAside();
  });

  llmSettingsButtonClose.addEventListener('click', () => {
    toggleDisplay(llmSettingsContainer);
    toggleSettingsAside();
  });

  appSettingsButtonClose.addEventListener('click', () => {
    toggleDisplay(appSettingsContainer);
    toggleSettingsAside();
  });


  // ------------------------------
  // WINDOW EVENTS
  // ------------------------------
  window.addEventListener('resize', guiSizeChange);
  window.addEventListener('orientationchange', guiSizeChange);

  window.addEventListener('wheel', e => {
    if (e.shiftKey || e.ctrlKey) resize_textbox();
  });

  // ------------------------------
  // MODEL SELECT
  // ------------------------------
  modelsSelectDropdown.addEventListener('change', e => {
    savedModelSelected = e.target.value;
    localStorage.setItem('modelSelected', savedModelSelected);
  });

  // ------------------------------
  // MESSAGE INPUT
  // ------------------------------
  appSaveSysPromptButton.addEventListener('click', saveSystemPrompt);
  sendButton.addEventListener('click', runSend);
  saveSettingsButton.addEventListener('click', saveSettings);

  messageInput.addEventListener('input', () => {
    if (messageInput.value === '') {
      messageInput.classList.add('normal');
      messageInput.classList.remove('expanded');
    }
  });

  messageInput.addEventListener('paste', () =>
    setTimeout(resize_textbox, 100)
  );

  messageInput.addEventListener('keypress', e => {
    if (e.key === 'Enter') {
      if (e.shiftKey || !SendOnEnter) {
        e.preventDefault();
        const pos = messageInput.selectionStart;
        messageInput.value =
          messageInput.value.slice(0, pos) + '\n' + messageInput.value.slice(pos);
        messageInput.selectionStart = messageInput.selectionEnd = pos + 1;
        resize_textbox();
      } else {
        e.preventDefault();
        runSend();
      }
    }
  });

  loadActiveModels();
});




function URLadd(path, baseurl) {
  if (baseurl.endsWith('/')) {
    return baseurl + path.replace(/^\/+/, '');
  } else {
    return baseurl + '/' + path.replace(/^\/+/, '');
  }
}


// ------------------------------
// TEXTBOX RESIZE
// ------------------------------
function resize_textbox() {
  messageInput.style.height = '0px';

  if (messageInput.classList.contains('normal')) {
    messageInput.classList.add('expanded');
    messageInput.classList.remove('normal');
  }

  messageInput.style.height = messageInput.scrollHeight + 'px';
}


// ------------------------------
// SEND MESSAGE FLOW
// ------------------------------
function runSend() {
  if (!isSending) {
    doSendMessage();
  }
}

async function doSendMessage() {
  try {
    isSending = true;
    sendButton.textContent = 'Cancel';
    showLoading();

    await sendMessage();

    if (!messageInput.classList.contains('normal')) {
      messageInput.classList.add('normal');
      messageInput.classList.remove('expanded');
    }

    messageInput.value = "";
    resize_textbox();

  } catch (error) {
    console.error('Error sending message:', error);
  } finally {
    DoneSend();
  }
}

function DoneSend() {
  isSending = false;
  sendButton.textContent = 'Send';
  hideLoading();
}


// ------------------------------
// LOADING INDICATORS
// ------------------------------
function showLoading() {
  loadingIndicator.style.display = 'flex';
}

function hideLoading() {
  loadingIndicator.style.display = 'none';
}


// ------------------------------
// SAVE SETTINGS
// ------------------------------
function saveSettings() {
  localStorage.setItem('apiUrl', apiUrlInput.value);
  localStorage.setItem('clientId', clientIdInput.value);
  localStorage.setItem('clientSecret', clientSecretInput.value);
  localStorage.setItem('clientStream', !clientStreamInput.checked);

  options.saveOptions(getCurrentOptions());

  systemPrompt = syspromptInput.value;
  resetConnection();
}


// ------------------------------
// SETTINGS PANEL STATE
// ------------------------------
function toggleSettingsAside() {
  const anyOpen =
    cloudSettingsContainer.style.display === 'flex' ||
    llmSettingsContainer.style.display === 'flex' ||
    appSettingsContainer.style.display === 'flex';

  settingsAside.style.display = anyOpen ? 'flex' : 'none';

  cloudSettingsButton.classList.toggle(
    'active',
    cloudSettingsContainer.style.display === 'flex'
  );

  llmSettingsButton.classList.toggle(
    'active',
    llmSettingsContainer.style.display === 'flex'
  );

  appSettingsButton.classList.toggle(
    'active',
    appSettingsContainer.style.display === 'flex'
  );
}


// secure-json-parse.js (browser version)
(function () {
  'use strict';

  const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
  const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;

  function filter(obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {
    let next = [obj];

    while (next.length) {
      const nodes = next;
      next = [];

      for (const node of nodes) {
        if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) {
          if (safe === true) return null;
          if (protoAction === 'error') throw new SyntaxError('Object contains forbidden prototype property');
          delete node.__proto__;
        }

        if (
          constructorAction !== 'ignore' &&
          Object.prototype.hasOwnProperty.call(node, 'constructor') &&
          node.constructor !== null &&
          typeof node.constructor === 'object' &&
          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')
        ) {
          if (safe === true) return null;
          if (constructorAction === 'error') throw new SyntaxError('Object contains forbidden prototype property');
          delete node.constructor;
        }

        for (const key in node) {
          const value = node[key];
          if (value && typeof value === 'object') next.push(value);
        }
      }
    }
    return obj;
  }

  function _parse(text, reviver, options) {
    if (options == null && reviver && typeof reviver === 'object') {
      options = reviver;
      reviver = undefined;
    }

    if (text && text.charCodeAt && text.charCodeAt(0) === 0xFEFF) {
      text = text.slice(1);
    }

    const obj = JSON.parse(text, reviver);

    if (obj === null || typeof obj !== 'object') return obj;

    const protoAction = (options && options.protoAction) || 'error';
    const constructorAction = (options && options.constructorAction) || 'error';

    if (protoAction === 'ignore' && constructorAction === 'ignore') return obj;

    if (protoAction !== 'ignore' && constructorAction !== 'ignore') {
      if (!suspectProtoRx.test(text) && !suspectConstructorRx.test(text)) return obj;
    } else if (protoAction !== 'ignore') {
      if (!suspectProtoRx.test(text)) return obj;
    } else {
      if (!suspectConstructorRx.test(text)) return obj;
    }

    return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
  }

  function safeParse(text, reviver) {
    try {
      return _parse(text, reviver, { safe: true });
    } catch {
      return undefined;
    }
  }

  // expose globally
  window.secureParse = safeParse;

})();


</script>
</html>
