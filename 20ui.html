<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rogue LLM Chat</title>
    <link rel="manifest" href="manifest.json" crossorigin="use-credentials">
</head>

<style>
/* RESET */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  height: 100%;
}

body {
  font-family: Arial, sans-serif;
  line-height: 1.6;
  color: #333;
  background: #f9f9f9;
  font-size: 16px;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}

/* UTILITY CLASSES */
.rounded { border-radius: 10px; }
.text-wrap {
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word;
}
.flex { display: flex; }
.center { justify-content: center; align-items: center; }

/* NAV BAR */
.nav-bar {
  position: fixed;
  top: 0;
  height: 4dvh;
  width: 100dvw;
  display: flex;
  justify-content: flex-end;
  background: #444;
  color: #ddd;
  padding-top: .5dvh;
}

.nav-bar-button {
  padding: .5dvh;
  margin-right: 2dvw;
  border: .2dvh solid #ccc;
  border-radius: 2dvh;
  background: #408000;
  font-size: 1.5dvh;
  font-weight: bold;
  cursor: pointer;
}
.nav-bar-button:hover {
  background: #222;
  color: #ddd;
}

/* LOGO */
.app-logo {
  margin-right: auto;
  padding: 0 .5dvh 0 1dvh;
  font-size: 2dvh;
  font-weight: bold;
  font-family: 'Arial Black', sans-serif;
  color: #00dd00;
  background: #333;
  border-radius: 10px;
  display: flex;
  align-items: center;
  text-shadow: 0 0 10px rgba(0,200,0,.5);
  box-shadow: 0 0 20px rgba(0,0,0,.5);
}
.app-logo::before {
  content: "";
  background: url('Rogue_icon.png') center/contain no-repeat;
  width: 3dvh;
  height: 3dvh;
  margin-right: 1dvh;
}

/* LOADING */
#loading-indicator {
  position: absolute;
  top: 30vh;
  left: 50%;
  transform: translateX(-50%);
  height: 14dvh;
  background: #000;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
#loading-indicator img {
  width: 22dvh;
  height: 22dvh;
}

/* CHAT BODY */
.chat-body-container {
  position: fixed;
  top: 4dvh;
  width: 100%;
  height: 88dvh;
  background: #444000;
  user-select: text;
  cursor: text;
  display: flex;
  justify-content: start;
  align-items: center;
}

.chat-body {
  padding: 10px 10px 1dvh;
  border-radius: 10px;
  overflow-y: auto;
  max-height: 100%;
}

.chat-body pre {
  margin-bottom: 2dvh;
  padding: 10px;
  border-radius: 10px;
}

/* MESSAGE BUBBLES */
.bubble {
  display: block;
  padding: 10px;
  border-radius: 10px;
  pointer-events: auto;
}
.user-bubble {
  background: linear-gradient(to bottom right, #03131a, #4682B4);
  color: #ddd;
}
.ai-bubble {
  background: linear-gradient(to bottom right, #599216, #679468);
  color: #000;
}

/* BUTTONS */
.button-save,
.button-close {
  font-size: 1.5dvh;
  font-weight: bold;
  width: 6dvh;
  height: 5dvh;
  border-radius: 2vw;
  cursor: pointer;
}
.button-save {
  margin-left: 2vw;
  border: .1vw solid #ccc;
  background: #444;
  color: #ddd;
}
.button-close {
  margin-left: 4vw;
  border: .1vw solid #ff0;
  background: #ff0080;
  color: #ddd;
}

/* SYSTEM PROMPT INPUT */
#app-system-prompt-input {
  width: 98%;
  height: 20dvh;
  padding: .5vw;
  font-size: .8rem;
  border: none;
  border-radius: 10px;
  background: #ddd;
  white-space: pre-wrap;
  overflow-wrap: break-word;
}

/* FOOTER */
footer {
  position: fixed;
  bottom: 0;
  width: 100vw;
  height: 8vh;
  max-height: 10vh;
  background: #444;
  overflow-y: auto;
  display: flex;
  align-items: center;
}

/* INPUT SECTION */
.input-section {
  position: fixed;
  bottom: .5dvw;
  width: 85vw;
  margin-left: 5vw;
  padding: 1dvw;
  background: #555;
  border-radius: 4vw;
  display: flex;
  align-items: center;
  height: fit-content;
}

#user-input {
  width: 90dvw;
  min-height: 4dvh;
  padding: 1dvh;
  border: 1px solid #ddd;
  border-radius: 2vw;
  font-family: Arial, sans-serif;
  font-size: clamp(.1dvh, 4dvw, 2.5dvh);
  resize: vertical;
  overflow-y: hidden;
  transition: border-color .2s, box-shadow .2s, background-color .2s;
}
#user-input:focus {
  outline: none;
  border-color: #005500;
  box-shadow: 0 0 5px rgba(0,255,0,.5);
  background: #add8e6;
}
#user-input.expanded {
  max-height: 40vh;
  overflow-y: auto;
}

/* SEND BUTTON */
#send-button {
  margin-left: 1vw;
  padding: .2vw 1vw;
  border: 1px solid #ccc;
  border-radius: 2vw;
  font-size: clamp(.1dvh, 4dvw, 2.5dvh);
  font-weight: bold;
  cursor: pointer;
}
#send-button:hover {
  background: #222;
  color: #ddd;
}

/* SETTINGS PANEL */
#settings-panel {
  position: fixed;
  top: 8vh;
  width: 80dvw;
  height: 80dvh;
  margin: 0 10dvw;
  background: rgba(128,128,128,.5);
  display: none;
  flex-wrap: wrap;
  justify-content: space-around;
  align-items: flex-start;
  gap: 10px;
}
#settings-panel.hidden {
  z-index: -1;
}

/* COLOR CLASSES */
.black { background: #111; }
.green { background: #408000; }
.yellow { background: #FF8000; }
.red { background: #F00; }
.active { background: #444111; }
.hidden { display: none; }

</style>

<body>
  <!-- Navigation Bar -->
  <nav class="nav-bar" id="nav-bar">
    <div class="app-logo" id="app-logo">Rogue 0Nex</div>
    <button id="app-settings-button" class="nav-bar-button" aria-label="Open app settings menu">⚙️ App</button>
    <button id="cloud-settings-button" class="nav-bar-button" aria-label="Open cloud settings menu">☁️ Cloud</button>
    <button id="llm-settings-button" class="nav-bar-button" aria-label="Open LLM settings menu">✨ LLM</button>
  </nav>

  <!-- Loading Indicator -->
  <div id="loading-indicator">
    <img src="loading.gif" alt="Loading...">
  </div>

  <!-- Chat Body -->
  <div class="chat-body-container" id="chat-body-container">
    <div class="chat-body" id="chat-body"></div>
  </div>

  <!-- Input Section -->
  <footer id="footer">
    <div class="input-section" id="input-section">
      <textarea id="user-input" class="normal" wrap="soft" placeholder="Type a message..."></textarea>
      <button id="send-button" type="button">Send</button>
    </div>
  </footer>

  <!-- Settings Panel -->
  <div id="settings-panel" class="settings-panel">

    <!-- App Settings -->
    <div id="app-settings-container" class="settings-group hidden">
      <h2>App Settings</h2>
      <form id="app-settings-form">
        <p>Screen Height: <span id="screen-height-value"></span></p>
        <p>Window Height: <span id="window-height-value"></span></p>
        <p>Screen Width: <span id="screen-width-display"></span></p>
        <p>Window Width: <span id="window-width-display"></span></p>
      </form>

      <label>System Prompt:</label>
      <textarea id="app-system-prompt-input" wrap="soft" placeholder="Type a message..."></textarea>

      <div class="button-container">
        <button id="app-save-sysprompt-button" class="button-save">&#128190; SAVE</button>
        <button id="app-settings-button-close" class="button-close" aria-label="Close app settings menu">&#9194; Close</button>
      </div>
    </div>

    <!-- Cloud Settings -->
    <div id="cloud-settings-container" class="settings-group hidden">
      <h2>Cloud Settings</h2>
      <form id="cloud-settings-form">
        <label for="api-url">API URL:</label>
        <input type="text" id="api-url" name="api-url">

        <label for="client-id">Client ID:</label>
        <input type="text" id="client-id" name="client-id">

        <label for="client-secret">Client Secret:</label>
        <input type="text" id="client-secret" name="client-secret">

        <label for="client-stream">Client Stream:</label>
        <input type="checkbox" id="client-stream" value="true" checked>
      </form>

      <div class="button-container">
        <button id="save-settings-button" class="button-save">&#128190; Save</button>
        <button id="cloud-settings-button-close" class="button-close">&#9194; Close</button>
      </div>
    </div>

    <!-- LLM Settings -->
    <div id="llm-settings-container" class="settings-group hidden">
      <h2>LLM Settings</h2>

      <label for="models-select">Select Model:</label>
      <select id="models-select">
        <option value="">[EMPTY]</option>
      </select>

      <p id="models-active-title">Active Model: <span id="models-active"></span></p>

      <div class="button-container">
        <button id="llm-settings-button-close" class="button-close">&#9194; Close</button>
      </div>
    </div>

  </div>
</body>


<script>


// DOM references
const ChatArea = document.querySelector('#chat-body');
const ChatAreaContainer = ChatArea;
const TempText = document.getElementById('temp-text-area');
const applogo = document.getElementById('app-logo');

let error_out = "";
let connectionReady = false;
let includeCreds = true;

function resetConnection() {
  connectionReady = false;
}

/* ------------------------------
   API REQUEST WRAPPER
--------------------------------*/
async function makeApiRequest(url, method, body = null, headers = null, blockOpen = false) {
  const controller = new AbortController();
  const signal = controller.signal;

  const timeout = headers ? 200000 : 30000;
  const timerId = setTimeout(() => controller.abort(), timeout);

  try {
    const fetchOptions = {
      method,
      ...(headers && { headers }),
      ...(body && { body }),
      ...(includeCreds && { credentials: "include" }),
      ...(!blockOpen && { signal })
    };

    const response = await fetch(url, fetchOptions);
    clearTimeout(timerId);

    if (!response.ok) {
      throw new Error(`API request failed: ${response.status} ${await response.text()}`);
    }

    return response;
  } catch (error) {
    clearTimeout(timerId);
    if (error.name === 'AbortError') return { error: 'Timeout exceeded' };
    return error;
  }
}

/* ------------------------------
   CONNECTION HANDSHAKE
--------------------------------*/
async function establishConnection() {
  if (connectionReady) return;

  const apiUrl = apiUrlInput.value.trim();
  const clientId = clientIdInput.value.trim();
  const clientSecret = clientSecretInput.value.trim();

  loadingIndicator.style.display = 'flex';
  applogo.classList.add('black');

  try {
    // 1. Try with credentials
    includeCreds = true;
    let url = URLadd("/api/ps", apiUrl);
    let response = await makeApiRequest(url, "GET");
    if (response.ok) return (connectionReady = true);

    applogo.classList.add('green');

    // 2. Try with CF Access headers
    if (clientId && clientSecret) {
      const headers = {
        "CF-Access-Client-Id": clientId,
        "CF-Access-Client-Secret": clientSecret,
        "Content-Type": "application/json",
        "ai": "1"
      };
      includeCreds = true;
      response = await makeApiRequest(URLadd("", apiUrl), "GET", null, headers);
      if (response.ok) return (connectionReady = true);
    }

    applogo.classList.add('yellow');

    // 3. Try without credentials
    includeCreds = false;
    response = await makeApiRequest(URLadd("/api/ps", apiUrl), "GET");
    if (response.ok) return (connectionReady = true);

    applogo.classList.add('red');
    throw new Error("Not connected to API");
  } finally {
    loadingIndicator.style.display = 'none';
    applogo.classList.remove('black', 'green', 'yellow', 'red');
  }
}

/* ------------------------------
   LOAD ACTIVE MODEL
--------------------------------*/
async function loadActiveModels() {
  const apiUrl = apiUrlInput.value.trim();
  const modelsactive = document.getElementById('models-active');

  try {
    await establishConnection();
    if (!connectionReady) throw new Error("No connection");

    const res = await makeApiRequest(URLadd("/api/ps", apiUrl), "GET");
    if (!res.ok) throw new Error("Bad response");

    const models = await res.json();
    if (!Array.isArray(models.models) || models.models.length === 0) {
      throw new Error("Invalid model list");
    }

    let selected = models.models[0].name;
    if (selected === "[EMPTY]") throw new Error("Empty model list");

    for (const m of models.models) {
      if (m.name === savedModelSelected) {
        selected = savedModelSelected;
        break;
      }
    }

    modelsSelectDropdown.value = selected;
    savedModelSelected = selected;
    modelsactive.textContent = selected;
  } finally {
    loadingIndicator.style.display = 'none';
  }
}

/* ------------------------------
   LOAD ALL MODELS
--------------------------------*/
async function loadModels() {
  const apiUrl = apiUrlInput.value.trim();

  try {
    await establishConnection();
    loadingIndicator.style.display = 'flex';

    // Clear dropdown
    while (modelsSelectDropdown.options.length) {
      modelsSelectDropdown.remove(0);
    }

    const res = await makeApiRequest(URLadd("/api/tags", apiUrl), "GET");
    if (!res.ok) throw new Error("Bad response");

    const models = await res.json();
    if (!Array.isArray(models.models)) throw new Error("Invalid model list");

    models.models.forEach(model => {
      if (!model.name.includes("embed")) {
        const opt = new Option(model.name, model.name);
        modelsSelectDropdown.add(opt);
      }
    });

    let selected = modelsSelectDropdown.options[0]?.value;
    for (const opt of modelsSelectDropdown.options) {
      if (opt.value === savedModelSelected) {
        selected = savedModelSelected;
        break;
      }
    }

    modelsSelectDropdown.value = selected;
    savedModelSelected = selected;
    localStorage.setItem('modelSelected', selected);
  } finally {
    loadingIndicator.style.display = 'none';
  }
}

/* ------------------------------
   CHAT HISTORY
--------------------------------*/
function GetChatHistory() {
  const bubbles = ChatArea.querySelectorAll('pre');
  return bubbles.length
    ? [...bubbles].map(b => b.textContent).join('\n\n')
    : '';
}

/* ------------------------------
   SEND MESSAGE
--------------------------------*/
async function sendMessage() {
  const apiUrl = apiUrlInput.value.trim();
  const chatMessage = messageInput.value;
  const clientStream = clientStreamInput.value !== "false";
  const modelSelected = savedModelSelected;

  if (!modelSelected || !chatMessage) {
    throw new Error("Missing model or message");
  }

  const messages = { conversation: [] };

  if (systemPrompt) {
    messages.conversation.push({ role: "system", content: systemPrompt });
  }

  const bubbles = ChatArea.querySelectorAll('pre');
  [...bubbles].forEach(b => {
    const text = b.textContent;
    if (text.startsWith("User:")) {
      messages.conversation.push({ role: "user", content: text.replace("User:", "").trim() });
    } else if (text.startsWith("AI:")) {
      messages.conversation.push({ role: "assistant", content: text.replace("AI:", "").trim() });
    }
  });

  messages.conversation.push({ role: "user", content: chatMessage });

  const payload = {
    model: modelSelected,
    messages: messages.conversation,
    stream: clientStream
  };

  await establishConnection();

  const res = await makeApiRequest(
    URLadd("/api/chat", apiUrl),
    "POST",
    JSON.stringify(payload),
    null,
    true
  );

  if (!res.ok) throw new Error("Chat request failed");

  await p(chatMessage, res, payload.stream);
}

/* ------------------------------
   PROCESS RESPONSE
--------------------------------*/
async function p(chatMessage, res, isStream) {
  try {
    createBubble("user", chatMessage);
    ChatAreaContainer.scrollTo({ top: ChatAreaContainer.scrollHeight, behavior: 'smooth' });

    const bubble = createBubble("ai", "");

    if (isStream) {
      const reader = res.body.getReader();
      const processor = new StreamingJsonProcessor();
      let partial = "";

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        partial += new TextDecoder().decode(value);
        const chunks = processor.processChunk(partial);
        partial = "";

        chunks.forEach(content => {
          bubble.textContent += replaceCharEncodings(content);
          resizePre(bubble);
          ChatAreaContainer.scrollTo({ top: ChatAreaContainer.scrollHeight, behavior: 'smooth' });
        });
      }
    } else {
      bubble.textContent += "\n" + await res.text();
    }

    messageInput.focus();
  } finally {
    loadingIndicator.style.display = 'none';
  }
}

/* ------------------------------
   STREAMING JSON PROCESSOR
--------------------------------*/
class StreamingJsonProcessor {
  constructor() {
    this.buffer = "";
  }

  processChunk(chunk) {
    this.buffer += chunk;
    const out = [];

    while (true) {
      const end = this.findNextJsonEndIndex(this.buffer);
      if (end === -1) break;

      const jsonString = this.sanitizeJson(this.buffer.slice(0, end));
      try {
        const content = extractContent(jsonString);
        if (content) out.push(content);
      } catch (e) {
        console.error("JSON parse error:", e);
      }

      this.buffer = this.buffer.slice(end);
    }

    return out;
  }

  findNextJsonEndIndex(str) {
    let depth = 0;
    let inString = false;

    for (let i = 0; i < str.length; i++) {
      const c = str[i];

      if (c === '"' && str[i - 1] !== '\\') inString = !inString;
      if (!inString) {
        if (c === '{' || c === '[') depth++;
        if (c === '}' || c === ']') depth--;
        if (depth === 0) return i + 1;
      }
    }
    return -1;
  }

  sanitizeJson(str) {
    return str.trim().replace(/,\s*([\]}])/g, '$1');
  }
}







/**
 * Extract the content from a JSON string.
 *
 * @param {string} jsonString
 * @returns {string|null}
 */


function extractContent(jsonString) {

  if (!jsonString.endsWith(',"done":false}')) {
     return "";
  }
  
  let startMarker = '"content":';
  let endMarker = ',"done":'; 

  let startIndex = jsonString.indexOf(startMarker);
  if (startIndex === -1) {
    return null; 
  }

  startIndex += startMarker.length+1;

  let endIndex = jsonString.indexOf(endMarker, startIndex);
  if (endMarker === '}' && endIndex === -1) {
      endIndex = jsonString.lastIndexOf('}');
      if (endIndex === -1) return null;
  } else if (endIndex === -1) {
    return null; 
  }
  
  let content = jsonString.substring(startIndex, endIndex-2);

  return content;
}

function URLadd(path, baseurl) {
  if (baseurl.endsWith('/')) {
    return baseurl + path.replace(/^\/+/, '');
  } else {
    return baseurl + '/' + path.replace(/^\/+/, '');
  }
}


















/**
 * Safely parse JSON text into a plain object while preventing prototype pollution.
 * - Rejects non-string input.
 * - Uses JSON.parse with a reviver to strip dangerous keys.
 * - Returns null on parse error.
 *
 * @param {string} text
 * @returns {object|null}
 */
function safeJsonParse(text) {
  if (typeof text !== 'string') return null;
  try {
    // Reviver removes dangerous keys and ensures plain objects/arrays only
    return JSON.parse(text, (key, value) => {
      if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
        return undefined;
      }
      // Disallow functions or other non-serializable types
      if (typeof value === 'function') return undefined;
      return value;
    });
  } catch (e) {
    console.warn('safeJsonParse: invalid JSON', e);
    return null;
  }
}

/**
 * Strict text sanitizer for insertion into textContent.
 * - Removes control characters and a small set of punctuation that could be used in injection contexts.
 * - Keeps normal punctuation and whitespace.
 *
 * @param {string} text
 * @returns {string}
 */
function sanitizeText(text) {
  if (typeof text !== 'string') return '';
  // Remove null bytes and control characters except newline and tab
  // Also remove backticks and curly braces which are sometimes used in templating attacks
  return text.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F`{}<>]/g, '');
}

/**
 * Escape text for safe display if you ever need to use innerHTML (not recommended).
 * Prefer using textContent with sanitizeText instead.
 *
 * @param {string} str
 * @returns {string}
 */
function escapeForHTML(str) {
  if (typeof str !== 'string') return '';
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

/**
 * Decode a small, controlled set of escape sequences returned by the LLM stream.
 * - Only decodes explicit patterns we expect.
 * - Validates \uXXXX sequences before decoding.
 *
 * @param {string} text
 * @returns {string}
 */
function replaceCharEncodings(text) {
  if (typeof text !== 'string') return '';

  const charMap = {
    '\\&#10;': '\n',
    '\\&#13;': '\r',
    '\\u003c': '<',
    '\\u003e': '>',
    '\\u0026': '&',
    '\\u0027': "'"
  };

  return text.replace(/\\u[0-9a-fA-F]{4}|\\&#10;|\\&#13;/g, match => {
    if (match.startsWith('\\u')) {
      const hex = match.slice(2);
      if (/^[0-9a-fA-F]{4}$/.test(hex)) {
        return String.fromCharCode(parseInt(hex, 16));
      }
      return match;
    }
    return charMap[match] || match;
  });
}

/**
 * Safely extract the 'content' field from a streaming JSON fragment.
 * - Accepts either a JSON string or an already-parsed object.
 * - Uses safeJsonParse to avoid prototype pollution.
 * - Returns sanitized text or null if nothing valid found.
 *
 * Expected fragment shapes (examples):
 *  - '{"content":"..."}'
 *  - '{"delta":{"content":"..."}}'
 *
 * @param {string|object} fragment
 * @returns {string|null}
 */
function extractContentSafe(fragment) {
  let obj = fragment;
  if (typeof fragment === 'string') {
    obj = safeJsonParse(fragment);
    if (!obj) return null;
  }

  // Support nested shapes commonly used by streaming LLMs
  const content =
    (obj && typeof obj.content === 'string' && obj.content) ||
    (obj && obj.delta && typeof obj.delta.content === 'string' && obj.delta.content) ||
    null;

  if (!content) return null;

  // Decode known escapes, then sanitize for safe text insertion
  const decoded = replaceCharEncodings(content);
  return sanitizeText(decoded);
}

/* ---------------------------
   Integration hint for StreamingJsonProcessor
   Replace calls to extractContent(jsonString) with extractContentSafe(jsonString)
   and then assign the returned string to bubble.textContent (safe).
   Example usage inside your streaming loop:

   const jsonString = ...; // chunked string
   const content = extractContentSafe(jsonString);
   if (content) {
     bubble.textContent += content;
   }

   This ensures streaming fragments are parsed safely and sanitized.
----------------------------*/

/* Example small wrapper to parse and return content array from a buffer string.
   This mirrors the previous extractContent usage but uses safe parsing.
*/
function extractMultipleContentsFromBuffer(bufferStr) {
  // Attempt to split by newline-delimited JSON or by object boundaries.
  // Keep this conservative: only attempt to parse complete JSON objects.
  const results = [];
  // Quick heuristic: find top-level JSON objects by scanning for balanced braces.
  let depth = 0, start = -1, inString = false, prevChar = '';
  for (let i = 0; i < bufferStr.length; i++) {
    const ch = bufferStr[i];
    if (ch === '"' && prevChar !== '\\') inString = !inString;
    if (!inString) {
      if (ch === '{') {
        if (depth === 0) start = i;
        depth++;
      } else if (ch === '}') {
        depth--;
        if (depth === 0 && start !== -1) {
          const candidate = bufferStr.slice(start, i + 1);
          const content = extractContentSafe(candidate);
          if (content) results.push(content);
          start = -1;
        }
      }
    }
    prevChar = ch;
  }
  return results;
}























function guiSizeChange() {
  document.querySelector('.chat-body-container').style.height = '88dvh';
  document.querySelectorAll('.chat-body pre').forEach(resizePre);
}

function saveLayout() {
  localStorage.setItem('chatBodyHeight', chatBodyHeight);
}

function loadLayout() {
  chatBodyHeight = localStorage.getItem('chatBodyHeight');
}


function resizePre(pre) {
  pre.style.height = 'auto';
  pre.style.height = pre.scrollHeight + 'px';
}

function updateBubble(bubble) {
  bubble.style.height = bubble.scrollHeight + 'px';
}

function createBubble(role, text) {
  const bubble = document.createElement('pre');
  const prefix = role === 'user' ? 'User: ' : 'AI: ';

  bubble.className = role === 'user' ? 'user-bubble' : 'ai-bubble';
  bubble.textContent = prefix + text.replace(/\&#10;/g, "\&#13;\&#10;");
  bubble.style.height = 'auto';
  bubble.style.overflowY = 'hidden';
  bubble.rows = 1;
  bubble.disabled = true;

  chatBody.appendChild(bubble);
  bubble.style.height = bubble.scrollHeight + 'px';

  return bubble;
}

function displayTempOutput(tempTextArea) {
  tempTextArea.id = 'ai-bubble';
  tempTextArea.classList.add('ai-bubble');
  tempTextArea.style.display = 'block';
}















// Core chat elements
const chatBody = document.getElementById('chat-body');
const messageInput = document.getElementById('user-input');
const sendButton = document.getElementById('send-button');
const loadingIndicator = document.getElementById('loading-indicator');

// Layout tracking
let chatBodyHeight;
let screenHeight, windowHeight, screenWidth, windowWidth;

const sreenHeightDisplay = document.getElementById('screen-height-value');
const windowHeightDisplay = document.getElementById('window-height-value');
const screenWidthDisplay = document.getElementById('screen-width-display');
const windowWidthDisplay = document.getElementById('window-width-display');

// Settings UI
const cloudSettingsButton = document.getElementById('cloud-settings-button');
const cloudSettingsButtonClose = document.getElementById('cloud-settings-button-close');
const cloudSettingsContainer = document.getElementById('cloud-settings-container');

const chatOptionsButton = document.getElementById('chat-options-button');
const chatOptionsButtonClose = document.getElementById('chat-options-button-close');
const chatOptionsSaveButton = document.getElementById('chat-options-save-button');

const appSettingsButton = document.getElementById('app-settings-button');
const appSettingsButtonClose = document.getElementById('app-settings-button-close');
const appSettingsContainer = document.getElementById('app-settings-container');
const appSaveSysPromptButton = document.getElementById('app-save-sysprompt-button');
const syspromptInput = document.getElementById('app-system-prompt-input');

const llmSettingsButton = document.getElementById('llm-settings-button');
const llmSettingsButtonClose = document.getElementById('llm-settings-button-close');
const llmSettingsContainer = document.getElementById('llm-settings-container');
const saveSettingsButton = document.getElementById('save-settings-button');

// Model selection
const modelsSelectDropdown = document.getElementById('models-select');

// Cloud/API inputs
const apiUrlInput = document.getElementById('api-url');
const clientIdInput = document.getElementById('client-id');
const clientSecretInput = document.getElementById('client-secret');
const clientStreamInput = document.getElementById('client-stream');

// Misc UI
const darkModeButton = document.getElementById('dark-mode-button');
const body = document.body;

// Saved values
const savedApiUrl = localStorage.getItem('apiUrl');
const savedClientId = localStorage.getItem('clientId');
const savedClientSecret = localStorage.getItem('clientSecret');
const savedClientStream = localStorage.getItem('clientStream');
const savedDarkMode = localStorage.getItem('dark-mode');
const savedSystempPrompt = localStorage.getItem('system-prompt');
let savedModelSelected = localStorage.getItem('modelSelected');














const options = new Options();
const currentOptions = options.getOptions();



const settingsAside = document.querySelector('.settings-panel');
let isSending = false;


let SendOnEnter = true;


let systemPrompt = savedSystempPrompt;


loadLayout();



document.addEventListener('DOMContentLoaded', () => {

  setTimeout(() => requestAnimationFrame(guiSizeChange), 100);

  options.loadOptions();
  messageInput.focus();
  resize_textbox();

  document.querySelector('#models-active').textContent = "";

  // Load saved values
  if (savedApiUrl) apiUrlInput.value = savedApiUrl;
  if (savedClientId) clientIdInput.value = savedClientId;
  if (savedClientSecret) clientSecretInput.value = savedClientSecret;
  if (savedSystempPrompt) systemPrompt = savedSystempPrompt;

  clientStreamInput.checked = savedClientStream !== "true";

  if (savedModelSelected) {
    const opt = new Option(savedModelSelected, savedModelSelected);
    modelsSelectDropdown.add(opt);
    modelsSelectDropdown.value = savedModelSelected;
  }

  if (savedDarkMode === 'true') body.classList.add('dark-mode');

  /* ------------------------------
     SETTINGS PANEL TOGGLES
  --------------------------------*/
  const toggleDisplay = el =>
    el.style.display = (el.style.display === 'none' || !el.style.display) ? 'flex' : 'none';

  cloudSettingsButton.addEventListener('click', () => {
    toggleDisplay(cloudSettingsContainer);
    toggleSettingsAside();
  });

  cloudSettingsButtonClose.addEventListener('click', () => {
    toggleDisplay(cloudSettingsContainer);
    toggleSettingsAside();
  });

  chatOptionsSaveButton.addEventListener('click', () =>
    options.saveOptions(options.getOptions())
  );

  appSettingsButton.addEventListener('click', () => {
    toggleDisplay(appSettingsContainer);
    if (appSettingsContainer.style.display === 'flex') {
      syspromptInput.value = localStorage.getItem('system-prompt');
      guiSizeChange();
    }
    toggleSettingsAside();
  });

  llmSettingsButton.addEventListener('click', () => {
    if (llmSettingsContainer.style.display === 'none' || !llmSettingsContainer.style.display) {
      loadModels();
      loadActiveModels();
    }
    toggleDisplay(llmSettingsContainer);
    toggleSettingsAside();
  });

  llmSettingsButtonClose.addEventListener('click', () => {
    toggleDisplay(llmSettingsContainer);
    toggleSettingsAside();
  });

  appSettingsButtonClose.addEventListener('click', () => {
    toggleDisplay(appSettingsContainer);
    toggleSettingsAside();
  });

  /* ------------------------------
     WINDOW EVENTS
  --------------------------------*/
  window.addEventListener('resize', guiSizeChange);
  window.addEventListener('orientationchange', guiSizeChange);

  window.addEventListener('wheel', e => {
    if (e.shiftKey || e.ctrlKey) resize_textbox();
  });

  /* ------------------------------
     MODEL SELECT
  --------------------------------*/
  modelsSelectDropdown.addEventListener('change', e => {
    savedModelSelected = e.target.value;
    localStorage.setItem('modelSelected', savedModelSelected);
  });

  /* ------------------------------
     MESSAGE INPUT
  --------------------------------*/
  appSaveSysPromptButton.addEventListener('click', saveSystemPrompt);
  sendButton.addEventListener('click', runSend);
  saveSettingsButton.addEventListener('click', saveSettings);

  messageInput.addEventListener('input', () => {
    if (messageInput.value === '') {
      messageInput.classList.add('normal');
      messageInput.classList.remove('expanded');
    }
  });

  messageInput.addEventListener('paste', () =>
    setTimeout(resize_textbox, 100)
  );

  messageInput.addEventListener('keypress', e => {
    if (e.key === 'Enter') {
      if (e.shiftKey || !SendOnEnter) {
        e.preventDefault();
        const pos = messageInput.selectionStart;
        messageInput.value =
          messageInput.value.slice(0, pos) + '\n' + messageInput.value.slice(pos);
        messageInput.selectionStart = messageInput.selectionEnd = pos + 1;
        resize_textbox();
      } else {
        e.preventDefault();
        runSend();
      }
    }
  });

  loadActiveModels();
});

/* ------------------------------
   TEXTBOX RESIZE
--------------------------------*/
function resize_textbox() {
  messageInput.style.height = '0px';
  if (textarea.classList.contains('normal')) {
    messageInput.classList.add('expanded');
    messageInput.classList.remove('normal');
  }
  messageInput.style.height = messageInput.scrollHeight + 'px';
}

/* ------------------------------
   SEND MESSAGE
--------------------------------*/
function runSend() {
  if (!isSending) doSendMessage();
}

async function doSendMessage() {
  try {
    isSending = true;
    sendButton.textContent = 'Cancel';
    showLoading();

    await sendMessage();

    if (!textarea.classList.contains('normal')) {
      messageInput.classList.add('normal');
      messageInput.classList.remove('expanded');
    }

    messageInput.value = "";
  } catch (err) {
    console.error('Error sending message:', err);
  } finally {
    DoneSend();
  }
}

function DoneSend() {
  isSending = false;
  sendButton.textContent = 'Send';
  hideLoading();
}

/* ------------------------------
   LOADING INDICATORS
--------------------------------*/
function showLoading() {
  loadingIndicator.style.display = 'flex';
}

function hideLoading() {
  loadingIndicator.style.display = 'none';
}

/* ------------------------------
   SAVE SETTINGS
--------------------------------*/
function saveSettings() {
  localStorage.setItem('apiUrl', apiUrlInput.value);
  localStorage.setItem('clientId', clientIdInput.value);
  localStorage.setItem('clientSecret', clientSecretInput.value);
  localStorage.setItem('clientStream', !clientStreamInput.checked);

  options.saveOptions(currentOptions);

  systemPrompt = syspromptInput.value;
  resetConnection();
}

function saveSystemPrompt() {
  systemPrompt = syspromptInput.value;
  localStorage.setItem('system-prompt', systemPrompt);
}

/* ------------------------------
   SETTINGS ASIDE STATE
--------------------------------*/
function toggleSettingsAside() {
  const anyOpen =
    cloudSettingsContainer.style.display === 'flex' ||
    llmSettingsContainer.style.display === 'flex' ||
    appSettingsContainer.style.display === 'flex';

  settingsAside.style.display = anyOpen ? 'flex' : 'none';

  cloudSettingsButton.classList.toggle('active', cloudSettingsContainer.style.display === 'flex');
  llmSettingsButton.classList.toggle('active', llmSettingsContainer.style.display === 'flex');
  appSettingsButton.classList.toggle('active', appSettingsContainer.style.display === 'flex');
}

</script>
</html>
