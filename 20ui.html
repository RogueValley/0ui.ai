<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rogue LLM Chat</title>
    <link rel="manifest" href="manifest.json" crossorigin="use-credentials">
</head>

<style>
/* RESET */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  height: 100%;
}

body {
  font-family: Arial, sans-serif;
  line-height: 1.6;
  color: #333;
  background: #f9f9f9;
  font-size: 16px;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}

/* UTILITY CLASSES */
.rounded { border-radius: 10px; }
.text-wrap {
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word;
}
.flex { display: flex; }
.center { justify-content: center; align-items: center; }

/* NAV BAR */
.nav-bar {
  position: fixed;
  top: 0;
  height: 4dvh;
  width: 100dvw;
  display: flex;
  justify-content: flex-end;
  background: #444;
  color: #ddd;
  padding-top: .5dvh;
}

.nav-bar-button {
  padding: .5dvh;
  margin-right: 2dvw;
  border: .2dvh solid #ccc;
  border-radius: 2dvh;
  background: #408000;
  font-size: 1.5dvh;
  font-weight: bold;
  cursor: pointer;
}
.nav-bar-button:hover {
  background: #222;
  color: #ddd;
}

/* LOGO */
.app-logo {
  margin-right: auto;
  padding: 0 .5dvh 0 1dvh;
  font-size: 2dvh;
  font-weight: bold;
  font-family: 'Arial Black', sans-serif;
  color: #00dd00;
  background: #333;
  border-radius: 10px;
  display: flex;
  align-items: center;
  text-shadow: 0 0 10px rgba(0,200,0,.5);
  box-shadow: 0 0 20px rgba(0,0,0,.5);
}
.app-logo::before {
  content: "";
  background: url('Rogue_icon.png') center/contain no-repeat;
  width: 3dvh;
  height: 3dvh;
  margin-right: 1dvh;
}

/* LOADING */
#loading-indicator {
  position: absolute;
  top: 30vh;
  left: 50%;
  transform: translateX(-50%);
  height: 14dvh;
  background: #000;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
#loading-indicator img {
  width: 22dvh;
  height: 22dvh;
}

/* CHAT BODY */
.chat-body-container {
  position: fixed;
  top: 4dvh;
  width: 100%;
  height: 88dvh;
  background: #444000;
  user-select: text;
  cursor: text;
  display: flex;
  justify-content: start;
  align-items: center;
}

.chat-body {
  padding: 10px 10px 1dvh;
  border-radius: 10px;
  overflow-y: auto;
  max-height: 100%;
}

.chat-body pre {
  margin-bottom: 2dvh;
  padding: 10px;
  border-radius: 10px;
}

/* MESSAGE BUBBLES */
.bubble {
  display: block;
  padding: 10px;
  border-radius: 10px;
  pointer-events: auto;
}
.user-bubble {
  background: linear-gradient(to bottom right, #03131a, #4682B4);
  color: #ddd;
}
.ai-bubble {
  background: linear-gradient(to bottom right, #599216, #679468);
  color: #000;
}

/* BUTTONS */
.button-save,
.button-close {
  font-size: 1.5dvh;
  font-weight: bold;
  width: 6dvh;
  height: 5dvh;
  border-radius: 2vw;
  cursor: pointer;
}
.button-save {
  margin-left: 2vw;
  border: .1vw solid #ccc;
  background: #444;
  color: #ddd;
}
.button-close {
  margin-left: 4vw;
  border: .1vw solid #ff0;
  background: #ff0080;
  color: #ddd;
}

/* SYSTEM PROMPT INPUT */
#app-system-prompt-input {
  width: 98%;
  height: 20dvh;
  padding: .5vw;
  font-size: .8rem;
  border: none;
  border-radius: 10px;
  background: #ddd;
  white-space: pre-wrap;
  overflow-wrap: break-word;
}

/* FOOTER */
footer {
  position: fixed;
  bottom: 0;
  width: 100vw;
  height: 8vh;
  max-height: 10vh;
  background: #444;
  overflow-y: auto;
  display: flex;
  align-items: center;
}

/* INPUT SECTION */
.input-section {
  position: fixed;
  bottom: .5dvw;
  width: 85vw;
  margin-left: 5vw;
  padding: 1dvw;
  background: #555;
  border-radius: 4vw;
  display: flex;
  align-items: center;
  height: fit-content;
}

#user-input {
  width: 90dvw;
  min-height: 4dvh;
  padding: 1dvh;
  border: 1px solid #ddd;
  border-radius: 2vw;
  font-family: Arial, sans-serif;
  font-size: clamp(.1dvh, 4dvw, 2.5dvh);
  resize: vertical;
  overflow-y: hidden;
  transition: border-color .2s, box-shadow .2s, background-color .2s;
}
#user-input:focus {
  outline: none;
  border-color: #005500;
  box-shadow: 0 0 5px rgba(0,255,0,.5);
  background: #add8e6;
}
#user-input.expanded {
  max-height: 40vh;
  overflow-y: auto;
}

/* SEND BUTTON */
#send-button {
  margin-left: 1vw;
  padding: .2vw 1vw;
  border: 1px solid #ccc;
  border-radius: 2vw;
  font-size: clamp(.1dvh, 4dvw, 2.5dvh);
  font-weight: bold;
  cursor: pointer;
}
#send-button:hover {
  background: #222;
  color: #ddd;
}

/* SETTINGS PANEL */
#settings-panel {
  position: fixed;
  top: 8vh;
  width: 80dvw;
  height: 80dvh;
  margin: 0 10dvw;
  background: rgba(128,128,128,.5);
  display: none;
  flex-wrap: wrap;
  justify-content: space-around;
  align-items: flex-start;
  gap: 10px;
}
#settings-panel.hidden {
  z-index: -1;
}

/* COLOR CLASSES */
.black { background: #111; }
.green { background: #408000; }
.yellow { background: #FF8000; }
.red { background: #F00; }
.active { background: #444111; }
.hidden { display: none; }

</style>

<body>
  <!-- Navigation Bar -->
  <nav class="nav-bar" id="nav-bar">
    <div class="app-logo" id="app-logo">Rogue 0Nex</div>
    <button id="app-settings-button" class="nav-bar-button" aria-label="Open app settings menu">⚙️ App</button>
    <button id="cloud-settings-button" class="nav-bar-button" aria-label="Open cloud settings menu">☁️ Cloud</button>
    <button id="llm-settings-button" class="nav-bar-button" aria-label="Open LLM settings menu">✨ LLM</button>
  </nav>

  <!-- Loading Indicator -->
  <div id="loading-indicator">
    <img src="loading.gif" alt="Loading...">
  </div>

  <!-- Chat Body -->
  <div class="chat-body-container" id="chat-body-container">
    <div class="chat-body" id="chat-body"></div>
  </div>

  <!-- Input Section -->
  <footer id="footer">
    <div class="input-section" id="input-section">
      <textarea id="user-input" class="normal" wrap="soft" placeholder="Type a message..."></textarea>
      <button id="send-button" type="button">Send</button>
    </div>
  </footer>

  <!-- Settings Panel -->
  <div id="settings-panel" class="settings-panel">

    <!-- App Settings -->
    <div id="app-settings-container" class="settings-group hidden">
      <h2>App Settings</h2>
      <form id="app-settings-form">
        <p>Screen Height: <span id="screen-height-value"></span></p>
        <p>Window Height: <span id="window-height-value"></span></p>
        <p>Screen Width: <span id="screen-width-display"></span></p>
        <p>Window Width: <span id="window-width-display"></span></p>
      </form>

      <label>System Prompt:</label>
      <textarea id="app-system-prompt-input" wrap="soft" placeholder="Type a message..."></textarea>

      <div class="button-container">
        <button id="app-save-sysprompt-button" class="button-save">&#128190; SAVE</button>
        <button id="app-settings-button-close" class="button-close" aria-label="Close app settings menu">&#9194; Close</button>
      </div>
    </div>

    <!-- Cloud Settings -->
    <div id="cloud-settings-container" class="settings-group hidden">
      <h2>Cloud Settings</h2>
      <form id="cloud-settings-form">
        <label for="api-url">API URL:</label>
        <input type="text" id="api-url" name="api-url">

        <label for="client-id">Client ID:</label>
        <input type="text" id="client-id" name="client-id">

        <label for="client-secret">Client Secret:</label>
        <input type="text" id="client-secret" name="client-secret">

        <label for="client-stream">Client Stream:</label>
        <input type="checkbox" id="client-stream" value="true" checked>
      </form>

      <div class="button-container">
        <button id="save-settings-button" class="button-save">&#128190; Save</button>
        <button id="cloud-settings-button-close" class="button-close">&#9194; Close</button>
      </div>
    </div>

    <!-- LLM Settings -->
    <div id="llm-settings-container" class="settings-group hidden">
      <h2>LLM Settings</h2>

      <label for="models-select">Select Model:</label>
      <select id="models-select">
        <option value="">[EMPTY]</option>
      </select>

      <p id="models-active-title">Active Model: <span id="models-active"></span></p>

      <div class="button-container">
        <button id="llm-settings-button-close" class="button-close">&#9194; Close</button>
      </div>
    </div>

  </div>
</body>
<!-- remove the other module tag or combine files -->
<script type="module">

 



// DOM references
const ChatArea = document.querySelector('#chat-body');
const ChatAreaContainer = ChatArea;
const TempText = document.getElementById('temp-text-area');
const applogo = document.getElementById('app-logo');

let error_out = "";
let connectionReady = false;
let includeCreds = true;

function resetConnection() {
  connectionReady = false;
}

/* ------------------------------
   API REQUEST WRAPPER
--------------------------------*/
async function makeApiRequest(url, method, body = null, headers = null, blockOpen = false) {
  const controller = new AbortController();
  const signal = controller.signal;

  const timeout = headers ? 200000 : 30000;
  const timerId = setTimeout(() => controller.abort(), timeout);

  try {
    const fetchOptions = {
      method,
      ...(headers && { headers }),
      ...(body && { body }),
      ...(includeCreds && { credentials: "include" }),
      ...(!blockOpen && { signal })
    };

    const response = await fetch(url, fetchOptions);
    clearTimeout(timerId);

    if (!response.ok) {
      throw new Error(`API request failed: ${response.status} ${await response.text()}`);
    }

    return response;
  } catch (error) {
    clearTimeout(timerId);
    if (error.name === 'AbortError') return { error: 'Timeout exceeded' };
    return error;
  }
}

/* ------------------------------
   CONNECTION HANDSHAKE
--------------------------------*/
async function establishConnection() {
  if (connectionReady) return;

  const apiUrl = apiUrlInput.value.trim();
  const clientId = clientIdInput.value.trim();
  const clientSecret = clientSecretInput.value.trim();

  loadingIndicator.style.display = 'flex';
  applogo.classList.add('black');

  try {
    // 1. Try with credentials
    includeCreds = true;
    let url = URLadd("/api/ps", apiUrl);
    let response = await makeApiRequest(url, "GET");
    if (response.ok) return (connectionReady = true);

    applogo.classList.add('green');

    // 2. Try with CF Access headers
    if (clientId && clientSecret) {
      const headers = {
        "CF-Access-Client-Id": clientId,
        "CF-Access-Client-Secret": clientSecret,
        "Content-Type": "application/json",
        "ai": "1"
      };
      includeCreds = true;
      response = await makeApiRequest(URLadd("", apiUrl), "GET", null, headers);
      if (response.ok) return (connectionReady = true);
    }

    applogo.classList.add('yellow');

    // 3. Try without credentials
    includeCreds = false;
    response = await makeApiRequest(URLadd("/api/ps", apiUrl), "GET");
    if (response.ok) return (connectionReady = true);

    applogo.classList.add('red');
    throw new Error("Not connected to API");
  } finally {
    loadingIndicator.style.display = 'none';
    applogo.classList.remove('black', 'green', 'yellow', 'red');
  }
}

/* ------------------------------
   LOAD ACTIVE MODEL
--------------------------------*/
async function loadActiveModels() {
  const apiUrl = apiUrlInput.value.trim();
  const modelsactive = document.getElementById('models-active');

  try {
    await establishConnection();
    if (!connectionReady) throw new Error("No connection");

    const res = await makeApiRequest(URLadd("/api/ps", apiUrl), "GET");
    if (!res.ok) throw new Error("Bad response");

    const models = await res.json();

    let selected = models.models[0].name;
    if (selected === "[EMPTY]") throw new Error("Empty model list");

    for (const m of models.models) {
      if (m.name === savedModelSelected) {
        selected = savedModelSelected;
        break;
      }
    }

    modelsSelectDropdown.value = selected;
    savedModelSelected = selected;
    modelsactive.textContent = selected;
  } finally {
    loadingIndicator.style.display = 'none';
  }
}

/* ------------------------------
   LOAD ALL MODELS
--------------------------------*/
async function loadModels() {
  const apiUrl = apiUrlInput.value.trim();

  try {
    await establishConnection();
    loadingIndicator.style.display = 'flex';

    // Clear dropdown
    while (modelsSelectDropdown.options.length) {
      modelsSelectDropdown.remove(0);
    }

    const res = await makeApiRequest(URLadd("/api/tags", apiUrl), "GET");
    if (!res.ok) throw new Error("Bad response");

    const models = await res.json();
    if (!Array.isArray(models.models)) throw new Error("Invalid model list");

    models.models.forEach(model => {
      if (!model.name.includes("embed")) {
        const opt = new Option(model.name, model.name);
        modelsSelectDropdown.add(opt);
      }
    });

    let selected = modelsSelectDropdown.options[0]?.value;
    for (const opt of modelsSelectDropdown.options) {
      if (opt.value === savedModelSelected) {
        selected = savedModelSelected;
        break;
      }
    }

    modelsSelectDropdown.value = selected;
    savedModelSelected = selected;
    localStorage.setItem('modelSelected', selected);
  } finally {
    loadingIndicator.style.display = 'none';
  }
}

/* ------------------------------
   CHAT HISTORY
--------------------------------*/
function GetChatHistory() {
  const bubbles = ChatArea.querySelectorAll('pre');
  return bubbles.length
    ? [...bubbles].map(b => b.textContent).join('\n\n')
    : '';
}

/* ------------------------------
   SEND MESSAGE
--------------------------------*/
async function sendMessage() {
  const apiUrl = apiUrlInput.value.trim();
  const chatMessage = messageInput.value;
  const clientStream = clientStreamInput.value !== "false";
  const modelSelected = savedModelSelected;

  if (!modelSelected || !chatMessage) {
    throw new Error("Missing model or message");
  }

  const messages = { conversation: [] };

  if (systemPrompt) {
    messages.conversation.push({ role: "system", content: systemPrompt });
  }

  const bubbles = ChatArea.querySelectorAll('pre');
  [...bubbles].forEach(b => {
    const text = b.textContent;
    if (text.startsWith("User:")) {
      messages.conversation.push({ role: "user", content: text.replace("User:", "").trim() });
    } else if (text.startsWith("AI:")) {
      messages.conversation.push({ role: "assistant", content: text.replace("AI:", "").trim() });
    }
  });

  messages.conversation.push({ role: "user", content: chatMessage });

  const payload = {
    model: modelSelected,
    messages: messages.conversation,
    stream: clientStream
  };

  await establishConnection();

  const res = await makeApiRequest(
    URLadd("/api/chat", apiUrl),
    "POST",
    JSON.stringify(payload),
    null,
    true
  );

  if (!res.ok) throw new Error("Chat request failed");

  await p(chatMessage, res, payload.stream);
}















/**
 * Fallback safe JSON parse (reviver strips dangerous keys).
 * Uses imported secureParse when available.
 *
 * @param {string} text
 * @returns {object|null}
 */
function safeJsonParse(text) {
  if (typeof text !== 'string') return null;
  if (secureParse) {
    try { return secureParse(text); } catch (e) { /* fall through to local */ }
  }
  try {
    return JSON.parse(text, (k, v) => {
      if (k === '__proto__' || k === 'constructor' || k === 'prototype') return undefined;
      if (typeof v === 'function') return undefined;
      return v;
    });
  } catch (e) {
    return null;
  }
}

/**
 * Decode only the explicit escape sequences expected from the LLM stream.
 * Keeps decoding conservative to avoid turning text into HTML.
 *
 * @param {string} text
 * @returns {string}
 */
function replaceCharEncodings(text) {
  if (typeof text !== 'string') return '';
  const map = {
    '\\&#10;': '\n',
    '\\&#13;': '\r',
    '\\u003c': '<',
    '\\u003e': '>',
    '\\u0026': '&',
    '\\u0027': "'"
  };
  return text.replace(/\\u[0-9a-fA-F]{4}|\\&#10;|\\&#13;/g, m => {
    if (m.startsWith('\\u')) {
      const hex = m.slice(2);
      if (/^[0-9a-fA-F]{4}$/.test(hex)) return String.fromCharCode(parseInt(hex, 16));
      return m;
    }
    return map[m] || m;
  });
}

/**
 * Minimal sanitizer for textContent insertion.
 * Removes control chars and a few risky punctuation characters.
 *
 * @param {string} s
 * @returns {string}
 */
function sanitizeText(s) {
  if (typeof s !== 'string') return '';
  return s.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F`{}<>]/g, '');
}

/**
 * Safe extractor: parse JSON fragment and return the content string (decoded + sanitized).
 * Accepts JSON string or object. Returns null if no valid content found.
 *
 * Expected shapes:
 *  - {"content":"..."}
 *  - {"delta":{"content":"..."}}
 *
 * @param {string|object} fragment
 * @returns {string|null}
 */
function extractContent(fragment) {
  let obj = fragment;
  if (typeof fragment === 'string') {
    obj = safeJsonParse(fragment);
    if (!obj) return null;
  }

  const content =
    (obj && typeof obj.content === 'string' && obj.content) ||
    (obj && obj.delta && typeof obj.delta.content === 'string' && obj.delta.content) ||
    null;

  if (!content) return null;

  const decoded = replaceCharEncodings(content);
  return sanitizeText(decoded);
}

/* ------------------------------
   PROCESS RESPONSE (improved, non-destructive)
--------------------------------*/
async function p(chatMessage, res, isStream) {
  try {
    createBubble("user", chatMessage);
    ChatAreaContainer.scrollTo({ top: ChatAreaContainer.scrollHeight, behavior: 'smooth' });

    const bubble = createBubble("ai", "");

    if (isStream && res && res.body && typeof res.body.getReader === 'function') {
      const reader = res.body.getReader();
      const processor = new StreamingJsonProcessor(); // keep existing processor class
      // Note: StreamingJsonProcessor maintains its own internal buffer.
      // We pass each chunk to it and let it manage partial fragments.
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = new TextDecoder().decode(value);
        // Pass only the new chunk to the processor; do NOT reset processor.buffer here.
        const contents = processor.processChunk(chunk);

        // processor.processChunk returns an array of raw content strings (previously via extractContent).
        // We now ensure each content is decoded and sanitized (extractContent already does that if processor uses extractContent).
        // But to be safe, run replaceCharEncodings + sanitizeText here as well.
        for (const raw of contents) {
          if (!raw) continue;
          const safe = sanitizeText(replaceCharEncodings(raw));
          bubble.textContent += safe;
          resizePre(bubble);
          ChatAreaContainer.scrollTo({ top: ChatAreaContainer.scrollHeight, behavior: 'smooth' });
        }
      }
    } else {
      // Non-stream fallback: treat response as text (decode + sanitize)
      const text = await res.text();
      bubble.textContent += "\n" + sanitizeText(replaceCharEncodings(String(text)));
      resizePre(bubble);
    }

    messageInput.focus();
  } finally {
    loadingIndicator.style.display = 'none';
  }
}
































function guiSizeChange() {
  document.querySelector('.chat-body-container').style.height = '88dvh';
  document.querySelectorAll('.chat-body pre').forEach(resizePre);
}

function saveLayout() {
  localStorage.setItem('chatBodyHeight', chatBodyHeight);
}

function loadLayout() {
  chatBodyHeight = localStorage.getItem('chatBodyHeight');
}


function resizePre(pre) {
  pre.style.height = 'auto';
  pre.style.height = pre.scrollHeight + 'px';
}

function updateBubble(bubble) {
  bubble.style.height = bubble.scrollHeight + 'px';
}

function createBubble(role, text) {
  const bubble = document.createElement('pre');
  const prefix = role === 'user' ? 'User: ' : 'AI: ';

  bubble.className = role === 'user' ? 'user-bubble' : 'ai-bubble';
  bubble.textContent = prefix + text.replace(/\&#10;/g, "\&#13;\&#10;");
  bubble.style.height = 'auto';
  bubble.style.overflowY = 'hidden';
  bubble.rows = 1;
  bubble.disabled = true;

  chatBody.appendChild(bubble);
  bubble.style.height = bubble.scrollHeight + 'px';

  return bubble;
}

function displayTempOutput(tempTextArea) {
  tempTextArea.id = 'ai-bubble';
  tempTextArea.classList.add('ai-bubble');
  tempTextArea.style.display = 'block';
}















// Core chat elements
const chatBody = document.getElementById('chat-body');
const messageInput = document.getElementById('user-input');
const sendButton = document.getElementById('send-button');
const loadingIndicator = document.getElementById('loading-indicator');

// Layout tracking
let chatBodyHeight;
let screenHeight, windowHeight, screenWidth, windowWidth;

const sreenHeightDisplay = document.getElementById('screen-height-value');
const windowHeightDisplay = document.getElementById('window-height-value');
const screenWidthDisplay = document.getElementById('screen-width-display');
const windowWidthDisplay = document.getElementById('window-width-display');

// Settings UI
const cloudSettingsButton = document.getElementById('cloud-settings-button');
const cloudSettingsButtonClose = document.getElementById('cloud-settings-button-close');
const cloudSettingsContainer = document.getElementById('cloud-settings-container');

const appSettingsButton = document.getElementById('app-settings-button');
const appSettingsButtonClose = document.getElementById('app-settings-button-close');
const appSettingsContainer = document.getElementById('app-settings-container');
const appSaveSysPromptButton = document.getElementById('app-save-sysprompt-button');
const syspromptInput = document.getElementById('app-system-prompt-input');

const llmSettingsButton = document.getElementById('llm-settings-button');
const llmSettingsButtonClose = document.getElementById('llm-settings-button-close');
const llmSettingsContainer = document.getElementById('llm-settings-container');
const saveSettingsButton = document.getElementById('save-settings-button');

// Model selection
const modelsSelectDropdown = document.getElementById('models-select');

// Cloud/API inputs
const apiUrlInput = document.getElementById('api-url');
const clientIdInput = document.getElementById('client-id');
const clientSecretInput = document.getElementById('client-secret');
const clientStreamInput = document.getElementById('client-stream');

// Misc UI
const darkModeButton = document.getElementById('dark-mode-button');
const body = document.body;

// Saved values
const savedApiUrl = localStorage.getItem('apiUrl');
const savedClientId = localStorage.getItem('clientId');
const savedClientSecret = localStorage.getItem('clientSecret');
const savedClientStream = localStorage.getItem('clientStream');
const savedDarkMode = localStorage.getItem('dark-mode');
const savedSystempPrompt = localStorage.getItem('system-prompt');
let savedModelSelected = localStorage.getItem('modelSelected');









class Options {
  constructor() {
    this.storageKey = 'options';
    this._options = this._loadFromStorage();
  }

  _loadFromStorage() {
    try {
      const raw = localStorage.getItem(this.storageKey);
      if (!raw) return {};
      const parsed = JSON.parse(raw);
      return (parsed && typeof parsed === 'object') ? parsed : {};
    } catch {
      return {};
    }
  }

  getOptions() {
    return { ...this._options };
  }

  loadOptions() {
    this._options = this._loadFromStorage();
    return this.getOptions();
  }

  saveOptions(opts) {
    if (!opts || typeof opts !== 'object') return false;

    // sanitize + secure save
    const safe = this._sanitize(opts);
    if (!safe) return false;

    this._options = safe;
    localStorage.setItem(this.storageKey, JSON.stringify(safe));
    return true;
  }

  _sanitize(opts) {
    const sensitive = [
      'apiKey', 'apiSecret', 'clientSecret',
      'password', 'token', 'accessToken'
    ];

    const copy = { ...opts };
    for (const k of sensitive) {
      if (k in copy) delete copy[k];
    }

    const replacer = (key, value) =>
      typeof value === 'function' || typeof value === 'undefined'
        ? undefined
        : value;

    try {
      const json = JSON.stringify(copy, replacer);

      if (new Blob([json]).size > 100_000) {
        console.warn('Options: payload too large');
        return null;
      }

      return JSON.parse(json);
    } catch (e) {
      console.error('Options: sanitize failed', e);
      return null;
    }
  }
}

function saveSystemPrompt() {
  // Pull the latest value from the UI
  const value = syspromptInput.value;

  // Update the in‑memory system prompt
  systemPrompt = value;

  // Persist to localStorage
  localStorage.setItem('system-prompt', value);

  // Reset connection so the next request uses the new prompt
  resetConnection();
}


// ------------------------------
// GLOBAL STATE INITIALIZATION
// ------------------------------

// Options manager
const options = new Options();

// Always fetch fresh options when needed
function getCurrentOptions() {
  return options.getOptions();
}

// Cached DOM references
const settingsAside = document.querySelector('.settings-panel');

// Message‑send state
let isSending = false;

// Input behavior
let SendOnEnter = true;

// System prompt (safe fallback)
let systemPrompt = typeof savedSystempPrompt === 'string'
  ? savedSystempPrompt
  : '';

// Load layout settings early
loadLayout();




document.addEventListener('DOMContentLoaded', () => {

  // Initial UI adjustments
  setTimeout(() => requestAnimationFrame(guiSizeChange), 100);
  options.loadOptions();
  messageInput.focus();
  resize_textbox();

  document.querySelector('#models-active').textContent = "";

  // Load saved values
  if (savedApiUrl) apiUrlInput.value = savedApiUrl;
  if (savedClientId) clientIdInput.value = savedClientId;
  if (savedClientSecret) clientSecretInput.value = savedClientSecret;
  if (savedSystempPrompt) systemPrompt = savedSystempPrompt;

  clientStreamInput.checked = savedClientStream !== "true";

  if (savedModelSelected) {
    const opt = new Option(savedModelSelected, savedModelSelected);
    modelsSelectDropdown.add(opt);
    modelsSelectDropdown.value = savedModelSelected;
  }

  if (savedDarkMode === 'true') body.classList.add('dark-mode');

  // ------------------------------
  // SETTINGS PANEL TOGGLES
  // ------------------------------
  const toggleDisplay = el =>
    el.style.display = (el.style.display === 'none' || !el.style.display)
      ? 'flex'
      : 'none';

  cloudSettingsButton.addEventListener('click', () => {
    toggleDisplay(cloudSettingsContainer);
    toggleSettingsAside();
  });

  cloudSettingsButtonClose.addEventListener('click', () => {
    toggleDisplay(cloudSettingsContainer);
    toggleSettingsAside();
  });

  appSettingsButton.addEventListener('click', () => {
    toggleDisplay(appSettingsContainer);
    if (appSettingsContainer.style.display === 'flex') {
      syspromptInput.value = localStorage.getItem('system-prompt');
      guiSizeChange();
    }
    toggleSettingsAside();
  });

  llmSettingsButton.addEventListener('click', () => {
    if (llmSettingsContainer.style.display === 'none' || !llmSettingsContainer.style.display) {
      loadModels();
      loadActiveModels();
    }
    toggleDisplay(llmSettingsContainer);
    toggleSettingsAside();
  });

  llmSettingsButtonClose.addEventListener('click', () => {
    toggleDisplay(llmSettingsContainer);
    toggleSettingsAside();
  });

  appSettingsButtonClose.addEventListener('click', () => {
    toggleDisplay(appSettingsContainer);
    toggleSettingsAside();
  });


  // ------------------------------
  // WINDOW EVENTS
  // ------------------------------
  window.addEventListener('resize', guiSizeChange);
  window.addEventListener('orientationchange', guiSizeChange);

  window.addEventListener('wheel', e => {
    if (e.shiftKey || e.ctrlKey) resize_textbox();
  });

  // ------------------------------
  // MODEL SELECT
  // ------------------------------
  modelsSelectDropdown.addEventListener('change', e => {
    savedModelSelected = e.target.value;
    localStorage.setItem('modelSelected', savedModelSelected);
  });

  // ------------------------------
  // MESSAGE INPUT
  // ------------------------------
  appSaveSysPromptButton.addEventListener('click', saveSystemPrompt);
  sendButton.addEventListener('click', runSend);
  saveSettingsButton.addEventListener('click', saveSettings);

  messageInput.addEventListener('input', () => {
    if (messageInput.value === '') {
      messageInput.classList.add('normal');
      messageInput.classList.remove('expanded');
    }
  });

  messageInput.addEventListener('paste', () =>
    setTimeout(resize_textbox, 100)
  );

  messageInput.addEventListener('keypress', e => {
    if (e.key === 'Enter') {
      if (e.shiftKey || !SendOnEnter) {
        e.preventDefault();
        const pos = messageInput.selectionStart;
        messageInput.value =
          messageInput.value.slice(0, pos) + '\n' + messageInput.value.slice(pos);
        messageInput.selectionStart = messageInput.selectionEnd = pos + 1;
        resize_textbox();
      } else {
        e.preventDefault();
        runSend();
      }
    }
  });

  loadActiveModels();
});




function URLadd(path, baseurl) {
  if (baseurl.endsWith('/')) {
    return baseurl + path.replace(/^\/+/, '');
  } else {
    return baseurl + '/' + path.replace(/^\/+/, '');
  }
}


// ------------------------------
// TEXTBOX RESIZE
// ------------------------------
function resize_textbox() {
  messageInput.style.height = '0px';

  if (messageInput.classList.contains('normal')) {
    messageInput.classList.add('expanded');
    messageInput.classList.remove('normal');
  }

  messageInput.style.height = messageInput.scrollHeight + 'px';
}


// ------------------------------
// SEND MESSAGE FLOW
// ------------------------------
function runSend() {
  if (!isSending) {
    doSendMessage();
  }
}

async function doSendMessage() {
  try {
    isSending = true;
    sendButton.textContent = 'Cancel';
    showLoading();

    await sendMessage();

    if (!messageInput.classList.contains('normal')) {
      messageInput.classList.add('normal');
      messageInput.classList.remove('expanded');
    }

    messageInput.value = "";
    resize_textbox();

  } catch (error) {
    console.error('Error sending message:', error);
  } finally {
    DoneSend();
  }
}

function DoneSend() {
  isSending = false;
  sendButton.textContent = 'Send';
  hideLoading();
}


// ------------------------------
// LOADING INDICATORS
// ------------------------------
function showLoading() {
  loadingIndicator.style.display = 'flex';
}

function hideLoading() {
  loadingIndicator.style.display = 'none';
}


// ------------------------------
// SAVE SETTINGS
// ------------------------------
function saveSettings() {
  localStorage.setItem('apiUrl', apiUrlInput.value);
  localStorage.setItem('clientId', clientIdInput.value);
  localStorage.setItem('clientSecret', clientSecretInput.value);
  localStorage.setItem('clientStream', !clientStreamInput.checked);

  options.saveOptions(getCurrentOptions());

  systemPrompt = syspromptInput.value;
  resetConnection();
}


// ------------------------------
// SETTINGS PANEL STATE
// ------------------------------
function toggleSettingsAside() {
  const anyOpen =
    cloudSettingsContainer.style.display === 'flex' ||
    llmSettingsContainer.style.display === 'flex' ||
    appSettingsContainer.style.display === 'flex';

  settingsAside.style.display = anyOpen ? 'flex' : 'none';

  cloudSettingsButton.classList.toggle(
    'active',
    cloudSettingsContainer.style.display === 'flex'
  );

  llmSettingsButton.classList.toggle(
    'active',
    llmSettingsContainer.style.display === 'flex'
  );

  appSettingsButton.classList.toggle(
    'active',
    appSettingsContainer.style.display === 'flex'
  );
}




</script>
</html>
