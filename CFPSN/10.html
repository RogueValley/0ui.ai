<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CTF - SN - Rogue LLM Chat</title>
</head>

<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
html {
  height: 100%;
}
body {
  font-family: Arial, sans-serif;
  line-height: 1.6;
  color: #333;
  background-color: #f9f9f9;
  font-size: 16px;
  height: 100vh; 
  width: 100vw; 
  margin: 0; 

  top: 0;
  left: 0;
  min-height: 100vh;
  max-height: 100vh;
}

.nav-bar {
  position: fixed;
  top: 0;
  height: 4dvh; 
  display: flex;
  justify-content: space-between;
  background-color: #444;
  color: #ddd;
  padding-top: .5dvh;
  justify-content: flex-end;
  width: 100dvw;
}

.nav-bar-button {
  padding-right: 2dvh;
  padding: .5dvh;
  border: .2dvh solid #ccc;
  border-radius: 2dvh;
  background-color: #408000;
  width: fit-content; /* Added to size the container to its content horizontally */
  height: fit-content; /* Added to size the container to its content vertically */

  margin-right: 2dvw;
  font-size: 1.5dvh;

  font-weight: bold;
  cursor: pointer;
}

.nav-bar-button:hover {
  background-color: #222; /* Change background color on hover */
  color: #ddd; /* or color: white; */
}


.app-logo {
  margin-right: auto;
  font-size: 2dvh;
  padding-left:  .5dvh;
  padding-right: 1dvh;
  color: #00dd00; /* neon green */
  text-shadow: 0 0 10px rgba(0, 200, 0, 0.5); /* glow effect */
  font-weight: bold; /* bold font */
  font-family: 'Arial Black', sans-serif; /* modern font */
 background-color: #333; /* dark gray background */
   border-radius: 10px; /* rounded corners */
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); /* shadow effect */
  width: fit-content; /* Added to size the container to its content vertically */
  display: flex; /* Add this to use flexbox for icon and text alignment */
  align-items: center; /* Vertically center the icon and text */
}

.app-logo::before {
  content: "";
  background-image: url('./Rogue_icon.png');
  background-size: contain;
  width: 3dvh; /* Adjust the width to fit your icon size */
  height: 3dvh; /* Adjust the height to fit your icon size */
  margin-right: 1dvh; /* Add some space between the icon and text */
}


 
#loading-indicator {
  position: absolute;
  top: 30vh;
  left: 50%;
  transform: translateX(-50%);
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background-color: #000000;
  height: 14dvh;
}

#loading-indicator img {
  width: 22dvh; /* adjust the width to your liking */
  height: 22dvh;
}

.chat-body-container {  
  position: fixed;
  top: 4dvh;
  justify-content: start; /* Keep this */
  align-items: center;
  background-color: #444000;
  width: 100%; /* Make it full width */
  height: 88dvh;

  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
  cursor: text;
}

.chat-body {
  padding: 10px;
  padding-bottom: 1dvh;
  border-radius: 10px;
  overflow-y: auto; /* Allow the chat body to scroll */
  max-height: 100%; /* Set the maximum height of the chat body to the height of the container */
  

}

.chat-body pre {
  display: block; /* Changed from flex to block */
  margin-bottom: 2dvh;
  padding: 10px;
  border-radius: 10px;  

}

.user-bubble {
  display: block;
  padding: 10px;
  border-radius: 10px;
  background-image: linear-gradient(to bottom right, #03131a, #4682B4);
  color: #dddddd;
  white-space: pre-wrap; /* Allows text to wrap */
  word-wrap: break-word; /* Breaks long words */
  overflow-wrap: break-word; /* For very long words without spaces */
  pointer-events: auto;
}

.ai-bubble {
  display: block;
  padding: 10px;
  border-radius: 10px;
  background-image: linear-gradient(to bottom right, #599216, #679468);
  color: #000000;
  white-space: pre-wrap; /* Allows text to wrap */
  word-wrap: break-word; /* Breaks long words */
  overflow-wrap: break-word; /* For very long words without spaces */
  pointer-events: auto;
}


.button-save {
  font-size: 1.5dvh;
  font-weight: bold;
  width: 6dvh;
  height: 5dvh;
  margin-left: 2vw;
  border: 0.1vw solid #ccc;
  border-radius: 2vw;
  background-color: #444;
  color: #ddd;
  cursor: pointer;
}

.button-close {
  font-size: 1.5dvh;
  font-weight: bold;
  width: 6dvh;
  height: 5dvh;
  margin-left: 4vw;
  border: 0.1vw solid #ff0;
  border-radius: 2vw;
  background-color: #ff0080;
  color: #ddd;
  cursor: pointer;
}

#app-system-prompt-input{
  width: 98%;
  height: 20dvh;
  padding: 0.5vw;
  font-size: .8rem;
  border: none;
  border-radius: 10px;
  background-color: #ddd;
  white-space: pre-wrap; /* Allows text to wrap */
  word-wrap: break-word; /* Breaks long words */
  overflow-wrap: break-word; /* For very long words without spaces */
}

footer {
  position: fixed;
  bottom: 0;
  left: 0;

  width: 100vw;
  height: 8vh;
  max-height: 10vh; /* set a maximum height in pixels */
  background-color: #444;
  overflow-y: auto; /* add this to hide excess content if it exceeds the max height */
  align-items: center;
}

.input-section {
  align-items: center;
  height: clamp(2dvh, 4dvw, 3dvh); /* changed to auto */
  margin-left: 5vw;
  position: fixed;
  bottom: .5dvw;
  width: 85vw;
  padding: 1dvw; 
  padding-right: 1dvw;
  background-color: #555;
  border-radius: 4vw;
  display: flex;
  padding-top: 1vh;
  padding-bottom: 1vh;  
  height: fit-content; /* Added to size the container to its content vertically */
}

#user-input {
  width: 90dvw; /* fixed width relative to viewport */
  height: 4dvh; /* changed to auto */
  min-height: 4dvh; /* minimum height */
  font-size: clamp(.1dvh, 4dvh, 4dvw); /* cap font size based on width and height */
  border-radius: 2vw;
 
  padding: 1dvh; /* consistent padding relative to viewport */
  font-size: clamp(.1dvh, 4dvw, 2.5dvh); /* cap font size based on width and height */
  border: 1px solid #ddd; /* improved border color and width relative to viewport */
  box-shadow: 0 0 1px rgba(0, 0, 0, 0.1); /* added subtle shadow for depth relative to viewport */
  font-family: Arial, sans-serif; /* added font family for better typography */
  resize: vertical; /* allow resizing vertically */
  transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s ease-in-out;
  overflow-y: hidden; /* hide scrollbar */
}

#user-input::-webkit-scrollbar {
  display: none; /* hide scrollbar for Chrome and Safari */
}

#user-input::-moz-scrollbar {
  display: none; /* hide scrollbar for Firefox */
}

#user-input:focus {
  outline: none;
  -webkit-appearance: none; /* remove default Chrome/Mac focus ring */
  -moz-appearance: none; /* remove default Firefox focus ring */
  border-color: #005500; /* green border */
  box-shadow: 0 0 5px rgba(0, 255, 0, 0.5); /* green glow */
  background-color: #add8e6; /* light blue background */
  overflow-y: hidden; /* hide scrollbar */
}



#user-input.normal {
  overflow-y: hidden; 
  max-height: clamp(2dvh, 4dvw, 3dvh); /* cap font size based on width and height */
}

#user-input.expanded {
  max-height: 40vh; 
  overflow-y: auto; 
}

#send-button {
  font-size: clamp(.1dvh, 4dvw, 2.5dvh);
  font-weight: bold;
  margin-left: 1vw;
  padding: 1vw;
  padding-top: .2vw;
  padding-bottom: .2vw;  
  width: fit-content; /* Added to size the container to its content horizontally */
  height: fit-content; /* Added to size the container to its content vertically */

  border: 1px solid #ccc;
  border-radius: 2vw;
  cursor: pointer;
}

#send-button:hover {
  background-color: #222; /* Change background color on hover */
  color: #ddd;/* or color: white; */
}

#settings-panel {
  position: fixed;
  display: none; /* changed to flex */
  top: 8vh;
  height: 80dvh;
  width: 80dvw;
  flex-wrap: wrap; /* Allow containers to wrap to a new line */
  justify-content: space-around; /* Distribute containers horizontally */
  align-items: flex-start; /* Align containers to the top */
  gap: 10px; /* Add some spacing between containers */
  margin-left: 10dvw; 
  margin-right: 10dvw; 
  background-color: rgba(128, 128, 128, 0.5); /* gray and semi-transparent background */
}

#settings-panel.hidden {
  z-index: -1;
}


#app-settings-container,
#cloud-settings-container,
#llm-settings-container,
#chat-options-container {
  display: flex;
  padding: 1rem;
  background-color: #808000;
  border-radius: 10px;
  margin: 0.5rem; 
  width: fit-content; 
  height: fit-content; 
  font-size: .6rem;
  flex-direction: column; 
}



.black {
  background-color: #111111;
}
.green {
  background-color: #408000;
}
.yellow {
  background-color: #FF8000;
}
.red {
  background-color: #FF0000;
}
.active {
  background-color: #444111;
}
.hidden {
  display: none;
}</style>

<body>
    <!-- Main Page Container -->
    <div class="main-page">
        <!-- Navigation Bar -->
        <nav id="nav-bar" class="nav-bar">
            <div id="app-logo" class="app-logo">Rogue 0Nex</div>
        </nav>
<div id="loading-indicator">
  <img  src="loading.gif" alt="Loading...">
</div>
        <!-- Main Chat Content -->
              <div class="chat-body-container" id="chat-body-container">
                <div class="chat-body" id="chat-body"></div>
            </div>
    
        <!-- Input Section -->
        <footer id="footer">
            <div class="input-section" id="input-section">
                <textarea id="user-input" class="normal" wrap="soft" placeholder="Type a message..."></textarea>
                <button type="button" id="send-button">Send</button>
            </div>
        </footer>



</body><script>


const ChatArea = document.querySelector('#chat-body');
const ChatAreaContainer = document.querySelector('#chat-body');

const TempText = document.getElementById('temp-text-area');
const applogo = document.getElementById('app-logo');
let error_out="";
let connectionReady = false;
let includeCreds=true;

function resetConnection() {
  connectionReady = false;
  }
  
 
async function makeApiRequest(url, method, body = null, headers = null, blockOpen= false) {
  const controller = new AbortController();
  const signal = controller.signal;

  let timerId = setTimeout(() => {
    controller.abort();
  }, headers == null ? 30000 : 200000);
    
  try {

    const fetchOptions = {
      method,
      ...headers && {  headers },
      ...body && { body },
      ...includeCreds && { credentials: "include" }, 
     ...!blockOpen && { signal }
    };

    const response = await fetch(url, fetchOptions);

    clearTimeout(timerId); 

    if (!response.ok) {
      throw new Error(`API request failed with status code ${response.status}: ${await response.text()}`);
    }

    return response;
  } catch (error) {
    if (timerId) {
      clearTimeout(timerId); 
    }
    if (error.name === 'AbortError') {
      return { error: 'Timeout exceeded' };
    }
    return error;
  }
}

async function establishConnection() {
  if (!connectionReady) {
    connectionReady = false;
    const apiUrl = apiUrlInput;
    const clientId = clientIdInput;
    const clientSecret = clientSecretInput;
    
    
    try {
       let response;
       
       loadingIndicator.style.display = 'flex';
       applogo.classList.add('black');



       applogo.classList.add('green');
  
       try {
         if (!clientId || !clientSecret) {
           throw new Error("No API Key");
         }
         
         const headers = { "CF-Access-Client-Id": clientId, "CF-Access-Client-Secret": clientSecret, "Content-Type": "application/json", "ai": "1" };
         const url = new URL("", apiUrl);

         
         includeCreds = true;
          response = await makeApiRequest(url, "GET", null, headers);

         if (response.ok) {
           connectionReady = true;
           return;
         } 
        }
        catch (error) {
        } 
        
        
       applogo.classList.add('yellow');
  
        
      try {
       const url = new URL("/", apiUrl);
        includeCreds = false;
        response = await makeApiRequest(url, "GET");
      
        if (response.ok) {
          connectionReady = true;
             return;
        }
      }
      catch (error) {
      } 
        
      applogo.classList.add('red');
   
      connectionReady = false;
    }
    catch (error) {
      connectionReady = false;
    } 
    finally {
      loadingIndicator.style.display = 'none';
      if(connectionReady)
      {
        if (applogo.classList.contains('green')) applogo.classList.remove('green');
        if (applogo.classList.contains('yellow')) applogo.classList.remove('yellow');
        if (applogo.classList.contains('red')) applogo.classList.remove('red');
        if (applogo.classList.contains('black')) applogo.classList.remove('black');
      } 
    }
  }
  if (!connectionReady) {
    throw new Error("Not connected to API");
  }
}

function GetChatHistory() {
  const bubbles = ChatArea.querySelectorAll('pre');

  if (bubbles.length === 0) {
    return ''; 
  }

  const combinedText = [...bubbles].map(bubble => bubble.textContent).join('\&#10;\&#10;');
  return combinedText;
}

async function sendMessage() {
  
  const apiUrl = apiUrlInput;
  const clientId = clientIdInput;
  const clientSecret = clientSecretInput;
  const chatMessage = messageInput.value;




  if (!chatMessage|| messageInput.value == "") {
      throw new Error("Error !modelSelected || !chatMessage");  
  }

  try {

  let messages = {
    "conversation": []
  };



  const bubbles = ChatArea.querySelectorAll('pre');

  if (bubbles.length !== 0) {
    const historyMessages = [...bubbles].map(bubble => bubble.textContent);

    historyMessages.forEach((history) => {
      if (history.startsWith("User:")) {
        messages.conversation.push({
          "role": "user",
          "content": history.replace("User:", "").trim()
        });
      } else 
      if (history.startsWith("AI:")) {
        messages.conversation.push({
        "role": "assistant",
        "content": history.replace("AI:", "").trim()
         });
       }
    });
  }

  messages.conversation.push({
    "role": "user",
    "content": messageInput.value
  });


const payload = {
  "messages": messages.conversation
};


    let result;
    try {
      result = JSON.stringify(payload);
    } catch (error) {
      result = {};
    }

    await establishConnection();

    const url = new URL("/api/chat", apiUrl);
    const res = await makeApiRequest(url, "POST", result,null, true);

    if (res.ok) {
      p(chatMessage, res);
    } else {
      throw new Error("Error loading models");
    }
  } catch (error) {
    throw new Error("Error loading models");
  } 
 
}

async function p(chatMessage,res)
{
   
  try { 
          createBubble("user", chatMessage);

                              ChatAreaContainer.scrollTo({
                          top: ChatAreaContainer.scrollHeight - ChatAreaContainer.clientHeight,
                          behavior: 'smooth'
                        });
            const bubble = createBubble("ai", "");

            {
                const reader = res.body.getReader();
                let partialJson = "";
                const processor = new JsonProcessor(); 

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = new TextDecoder().decode(value);
                    partialJson += chunk;

                    const contentArray = processor.processChunk(partialJson); 
                    partialJson = ""; 

                    
                    
                    contentArray.forEach(content => {
                        bubble.textContent +=replaceCharEncodings(  content);

                        resizePre(bubble);
                    
                        if (ChatAreaContainer.scrollTop === ChatAreaContainer.scrollHeight - ChatAreaContainer.clientHeight) {
                        
                        } else if (ChatAreaContainer.scrollHeight > ChatAreaContainer.clientHeight) {
                          ChatAreaContainer.scrollTo({
                          top: ChatAreaContainer.scrollHeight - ChatAreaContainer.clientHeight,
                          behavior: 'smooth'
                          });
                        }
                        
                    });
                }
            } else {
                const resText = await res.text();
                bubble.textContent += `\&#10;${resText}`;
            }
         messageInput.focus();
 } catch (error) {
    throw new Error("Error loading models");
  } finally {
  loadingIndicator.style.display = 'none';

  }   
}

class JsonProcessor {
    constructor() {
        this.buffer = "";
    }

    /**
     * Process a chunk of JSON data and return an array of content.
     *
     * @param {string} chunk
     * @returns {string[]}
     */
    processChunk(chunk) {
        this.buffer += chunk;
        let contentArray = [];

        while (true) {
            const endIndex = this.findNextJsonEndIndex(this.buffer, 0);

            if (endIndex === -1) {
                break; 
            }

            const jsonString = this.sanitizeJson(this.buffer.substring(0, endIndex + 1));

            try {
                const jsonData = extractContent(jsonString);

                if (jsonData) {
                    contentArray.push(jsonData);
                }
            } catch (error) {
                console.error("Error parsing JSON:", error);
            }

            
            this.buffer = this.buffer.substring(endIndex + 1);
        }
        return contentArray;
    }

    /**
     * Find the index of the next complete JSON object in the buffer.
     *
     * @param {string} str
     * @param {number} startIndex
     * @returns {number}
     */
    findNextJsonEndIndex(str, startIndex) {
        let openBraces = 0;
        let openSquares = 0;
        let inString = false;
        let stringChar = null;

        for (let i = startIndex; i < str.length; i++) {
            const char = str[i];

            if (!inString) {
                if (char === '{' || char === '[') {
                    openBraces++;
                    openSquares++;
                } else if (char === '}' || char === ']') {
                    openBraces--;
                    openSquares--;
                }
            }

            if (openBraces === 0 && openSquares === 0 && !inString) {
                return i + 1;
            }
        }
        return -1;
    }

    sanitizeJson(jsonString) {
        
        let sanitizedString = jsonString.trim();

        
        sanitizedString = sanitizedString.replace(/,\s*([\]}])/g, '$1');

        return sanitizedString;
    }
}



function extractContent(jsonString) {

  if (!jsonString.endsWith(',"done":false}')) {
     return "";
  }
  
  let startMarker = '"content":';
  let endMarker = ',"done":'; 

  let startIndex = jsonString.indexOf(startMarker);
  if (startIndex === -1) {
    return null; 
  }

  startIndex += startMarker.length+1;

  let endIndex = jsonString.indexOf(endMarker, startIndex);
  if (endMarker === '}' && endIndex === -1) {
      endIndex = jsonString.lastIndexOf('}');
      if (endIndex === -1) return null;
  } else if (endIndex === -1) {
    return null; 
  }
  
  let content = jsonString.substring(startIndex, endIndex-2);

  return content;
}

function replaceCharEncodings(text) {
  
  if (typeof text !== 'string') {
    return 'Error: Input must be a string.';
  }

  
  const charMap = {
    "\\u003e": ">",
    "\\&#10;": "\&#10;",
    "\\u003c": "<",
    "\\u0026": "&", 
    "\\u0027": "'", 
    
  };

  function replaceMatch(match) {
    
    if (match.startsWith("\\u")) {
      try {
        
        return String.fromCharCode(parseInt(match.substring(2), 16));
      } catch (e) {
        console.error(`Error parsing Unicode escape sequence: ${e}`);
      }
    }

    
    return charMap[match] || match;
  }

  
  const regex = /\\u[0-9a-fA-F]{4}|\\&#10;|\\&#13;/g;
  return text.replace(regex, replaceMatch);
}




const chatBody = document.getElementById('chat-body');


let chatBodyHeight;

let screenHeight;
let windowHeight;
let screenWidth;
let windowWidth;

const sreenHeightDisplay = document.getElementById('screen-height-value');
const windowHeightDisplay = document.getElementById('window-height-value');

const screenWidthDisplay = document.getElementById('screen-width-display');
const windowWidthDisplay = document.getElementById('window-width-display');

const textarea = document.getElementById('user-input');


function guiSizeChange() {
  
  const mainChatContent = document.querySelector('.chat-body-container');
  mainChatContent.style.height = '88dvh';

  
  const bubbles = document.querySelectorAll('.chat-body pre');

  
  bubbles.forEach(abubble => {
resizePre(abubble) 
  });
}


function saveLayout() {
  localStorage.setItem('chatBodyHeight', chatBodyHeight);
}


function loadLayout() {
  chatBodyHeight = localStorage.getItem('chatBodyHeight');
}

  
  loadLayout();



function resizePre(preElement) {
  preElement.style.height = 'auto';
  preElement.style.height = preElement.scrollHeight + 'px';
}

function updateBubble(bubble) {
  const scrollHeight = bubble.scrollHeight;
  bubble.style.height = `${scrollHeight}px`;
}

function createBubble(role, text) {
  const bubble = document.createElement('pre');
  if (role === 'user') {
   bubble.className = 'user-bubble';
    bubble.textContent = "User: " + text.replace(/\&#10;/g, "\&#13;\&#10;");
  } else if (role === 'ai') {
   bubble.className = 'ai-bubble';
    bubble.textContent = "AI: " + text.replace(/\&#10;/g, "\&#13;\&#10;");
  }

  
  bubble.rows = 1;
  bubble.style.height = 'auto';
  bubble.style.overflowY = 'hidden';

  chatBody.appendChild(bubble);

  bubble.disabled = true;

  
  const scrollHeight = bubble.scrollHeight;
  bubble.style.height = `${scrollHeight}px`;
  
  return bubble;
}




function displayTempOutput(tempTextArea) {
  
  tempTextArea.id = 'ai-bubble';
  tempTextArea.classList.add('ai-bubble');

  
  tempTextArea.style.display = 'block'; 
}


const cloudSettingsButton = document.querySelector('#cloud-settings-button');
const cloudSettingsButtonClose = document.querySelector('#cloud-settings-button-close');
const cloudSettingsContainer = document.querySelector('#cloud-settings-container');



const appSettingsButton = document.querySelector('#app-settings-button');
const appSettingsButtonClose = document.querySelector('#app-settings-button-close');
const appSettingsContainer = document.querySelector('#app-settings-container');
const appSaveSysPromptButton = document.querySelector('#app-save-sysprompt-button');
const syspromptInput = document.querySelector('#app-system-prompt-input');

const llmSettingsButton = document.querySelector('#llm-settings-button');
const llmSettingsButtonClose = document.querySelector('#llm-settings-button-close');
const llmSettingsContainer = document.querySelector('#llm-settings-container');
const saveSettingsButton = document.querySelector('#save-settings-button');

const messageInput = document.querySelector('#user-input');
const sendButton = document.querySelector('#send-button');
const messageContainer = document.querySelector('.input-container');


const loadingIndicator = document.querySelector('#loading-indicator');

const apiUrlInput = 'https://cfp03.learnui.ai/';
const clientIdInput = '6d5ec9d9c25157460af4ef4e53407731.access';
const clientSecretInput = '5d70ced09cf0b75ed9dc56280509cdce946342745e49f1a5d39a27274cdac260';

const darkModeButton = document.querySelector('#dark-mode-button');
const body = document.body;


const savedApiUrl = localStorage.getItem('apiUrl');
const savedClientId = localStorage.getItem('clientId');
const savedClientSecret = localStorage.getItem('clientSecret');











const settingsAside = document.querySelector('.settings-panel');
let isSending = false;


let SendOnEnter = true;



document.addEventListener('DOMContentLoaded', () => {
  
  
  setTimeout(() => {
    requestAnimationFrame(guiSizeChange);
  }, 100); 
  
  
  
    messageInput.focus();
  resize_textbox(); 
   
  

  
  
  
window.addEventListener('resize', () => {
  guiSizeChange();
});


window.addEventListener('orientationchange', () => {
  guiSizeChange();
});
  window.addEventListener('wheel', (event) => {
  if (event.shiftKey || event.ctrlKey) {
    
  resize_textbox(); 
 
  }
});
  
  

  sendButton.addEventListener('click', runSend);


  messageInput.addEventListener('input', (event) => {
  if ( messageInput.value  === '') {
              messageInput.classList.add('normal');
         messageInput.classList.remove('expanded');
     

        }
  });
  messageInput.addEventListener('paste', function(event) {
     
  setTimeout(() => {
     resize_textbox(); 
     
     
  }, 100); 
  
  });
  
  messageInput.addEventListener('keypress', (event) => {
    if (event.key === 'Enter') {
      if (event.shiftKey || !SendOnEnter) {
        
        event.preventDefault();
        
                const cursorPosition = messageInput.selectionStart;
        const textBeforeCursor = messageInput.value.substring(0, cursorPosition);
        const textAfterCursor = messageInput.value.substring(cursorPosition, messageInput.value.length);
        messageInput.value = textBeforeCursor + '\&#10;' + textAfterCursor;
        messageInput.selectionStart = cursorPosition + 1;
        messageInput.selectionEnd = cursorPosition + 1;
        
        resize_textbox();
      } else {
        if(SendOnEnter)
        {
          
          event.preventDefault();
          runSend();
        }
      }
    }
      
  });

});

function resize_textbox() {
   messageInput.style.height = '0px';
        if(textarea.classList.contains('normal'))
         {
            messageInput.classList.add('expanded');
            messageInput.classList.remove('normal');
         }
        messageInput.style.height = messageInput.scrollHeight + 'px';

}

function runSend() {

  if (!isSending) 
  {
    doSendMessage();
  }
}

async function doSendMessage() {
  try{
       isSending = true;

       
       sendButton.textContent = 'Cancel';

       showLoading()
  
       await sendMessage();
    
       if(!textarea.classList.contains('normal'))
       {
         messageInput.classList.add('normal');
         messageInput.classList.remove('expanded');
       }
    
       messageInput.value ="";
     }
     catch (error) {
       console.error('Error sending message:', error);
     } 
     finally {
       DoneSend();
      }
}

function DoneSend() {
  isSending = false;
  
  sendButton.textContent = 'Send';

  hideLoading();
}

function showLoading() {
  
  loadingIndicator.style.display = 'flex';
}

function hideLoading() {
  
  loadingIndicator.style.display = 'none';

}


</script>
</html>
